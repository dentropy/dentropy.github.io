---
uuid: 889c6648-4cf6-4887-848e-b01c4e5f1e71
share: true
title: Backlog - Question Engine
---
* Write a blog post about the problem of producing intelligence by scraping Discord Servers.
* [Research BEAM Method](/Research BEAM Method)

## First Perfect my Obsidian Publisher

## TODO

* [Develop a game that can be used to run society itself](/Develop a game that can be used to run society itself)
* [What social and technical infrastructure are required to allow signed merkle proofs of data on the blockchain to preserve history?](/What social and technical infrastructure are required to allow signed merkle proofs of data on the blockchain to preserve history?)
* Usable Application
* NFT RBAC
* Begin work on Merkle Trees

CAN'T FIND NODE TO EMBED
![Question Engine Roadmap](/Question Engine Roadmap)
## TODO

* Current Questions
	* [For QE How does one Pin stuff to their profile?](/For QE How does one Pin stuff to their profile?)
	* [For QE Can you query the Tag's used via another user?](/For QE Can you query the Tag's used via another user?)
	* [For QE where are we writing the Obsidian Publisher Binding?](/For QE where are we writing the Obsidian Publisher Binding?)
	* [For QE How do we publish my Obsidiban Vault database](/For QE How do we publish my Obsidiban Vault database)
	* [For QE What standardized tags should we use?](/For QE What standardized tags should we use?)
	* [For QE Do we want Edges to have key values?](/For QE Do we want Edges to have key values?)
* Current Task
	* Write user story for how to add notes to a group and share that group with people
		* Remember we want to track how a user consumes media
		* Every person viewing every meme should have a transaction permission attached to it
	* Write user story about sharing Schema's
	* Write user story about all the different types of media, research tiddlywiki
* #TODO
	* Alright let's write this in scratch on Solidity and use Pinata
	* The edges also function as pointers
	* If you want to access a meme you need to have an edge that points at it
	* [What design decisions do I need to make for Question Engine?](/What design decisions do I need to make for Question Engine?)
	* Permission Schema
	* Figure out what you want hashed and how
	* Find all the incubator forms
	* Review user stories and other project documentation
	* Hire someone, a project manager, from tutor mentor and question them
	* Customer Research
		* Video Calls with People on Fiver
		* Hacklab
	* Clearly articulate POC Vision
		* I want people to engage with my PKM in a meaningful way so I can engage with them. I hope to do this by making the information within my PKM scarce so people are choosy then tracking how they spend their attention via token transactions.
		* I need a list of questions I actually want to publish
		* I need a list of user stories and components I need to implement
	* Run the Demo, and document the bugs
* Reminders
	* [Obsidian Publisher Script](/Obsidian Publisher Script)
	* [Question Engine Transformation Schema](/Question Engine Transformation Schema)
	* [User Flow Diagrams - QE](/User Flow Diagrams - QE) + [User Stories - QE](/f137b314-579f-42ab-8be5-1c72bf9ebcd9)
	* [How do you render styled HTML from REST response in REACT?](/How do you render styled HTML from REST response in REACT?)
	* [Questions for Question Engine](/a739aa8a-2a04-4f01-bd2e-0434d47d96bd)
	* [Question Engine - QE](/cc5cc49d-f554-4f29-b31a-b8789688e6a3)
	* [Development Backlog Board](https://gitlab.com/ddaemon/question-engine/-/boards/5337657)
	* [DDaemon Queries for Apps](/DDaemon Queries for Apps)
	* [Why would someone want to use question engine?](/Why would someone want to use question engine?)
	* For every person you know one can ask 1000's of questions to learn about your relationship with them. Similar types of questions can be asked of every piece of information you know. How attention is to be spent to meaningfully navigate what questions are worth answering.
	* You are a DAG.
	* Remember edges are like pointing at someone, you don't always want to be seen pointing
* Prompts
	* We need research questions
* Bugs
* Features
	* In Note Permissions
* Other Links

## Logs

* 2023-07-24T01:26:46-04:00
	* I need to ship something
	* Follow the plan you laid out
	* 
* 2023-07-20T09:00:31-04:00
	* Next is to be able to set put the Feed into the Context component
	* I also need to be able to set filters for the Feed component
	* We still need to scope out that part of the API
	* Alright let's save this and do some Rust
* 2023-07-20T08:47:53-04:00
	* Alright what's next?
	* Dude how do we do pinning?
	* How do we do public edges, that's a good question
	* What is the current problem?
	* We need to show the filters
	* We need to be able to select the meme's, that has to be stored in the state doesn't it, YES
* 2023-07-20T08:16:37-04:00
	* Alright so we loading the memes into the Feed thing?
	* Ya
	* So we are going to store those memes in useState right?
	* Of course
	* Shit gotta learn how to do that again
	* What is the other hook we nedd
	* Dude you already did all this copy your own dam code
* 2023-07-20T06:44:49-04:00
	* Alright what's next?
	* Do we start populating the feed, filter, and context
	* We need to make sure our feed and filter API is functional
	* Where is that documented
	* [POST query_memes](/8f9771f1-4961-4e47-bd7a-d973418e1a0b)
	* Do I have tests for that?
	* Yes
	* Paul your brain is fried, go on a walk
	* Alright I can do that
	* Next Step is to do a basic feed query and store it in the provider
	* Wait do we actually need to store the memes in the provider
	* No we just need to know what to query
	* We also need to be able to send a meme over to the Context
	* So we have a Filter query and a Context Meme
	* Yes
* 2023-07-20T05:57:39-04:00
	* So for Context Feed, do we need a react provider?
	* YES
	* Alright time to relearn that shit
	* What do we want in this provider
	* Ummm shit good question, EVERYTHING
	* Wait can we just props this shit?
	* We have the filter updating the feed and the feed updating the what do we call the view thing in the middle
	* We have the feed, filter, and context
	* The context can update the filter that can update the feed
	* Ya alright code this shit
	* So do we store the feed in the provider?
	* Yes
* 2023-07-20T05:48:48-04:00
	* Well we can just assign a tag
	* How do we query based on tags?
	* SHIT
	* Paul focus on User Journey
	* So how do I send people to see my blog?
	* There is no wiki view
	* So we create a new component, call it wiki view, have memes on the side, and have the full meme on the right
	* That will not work on mobile
	* No it can, we can do the collapsible sidebar thing that I did in keybase
	* So this can have the card view as well
	* Yes
	* What about the filters on the query
	* Those are on the top
	* Alright let's fucking code it
	* No first we need the query backend
	* What about it
	* See all public tweets, tweets from a person
	* Ya that's going to have to be on the other side, feed filter or something like that
	* Let's just code the components with dummy data
	* What do we call this
	* Thunk Pannel
	* No what else is there?
	* Context Feed Pannel, we don't even use it
	* Oh ya so we have the root memes on the left side, the filter on the right for the root memes, and the context in the middle
	* YES THIS WORKS
	* This shit designs itself
* 2023-07-20T05:41:55-04:00
	* Alright so what do we want Question Engine to be able to do?
	* Well we need to check out our user stories
	* Dude it can't replace twitter yet
	* I can make memes and show them to people
	* Dude can you please create a Card interface rather than the stupid grid component
	* No that is not the goal, I want my PKI accessable
	* How is that supposed to work?
	* How do people know where to start?
	* How do we pin stuff?
	* Shit 
* 2023-07-08T21:31:47-04:00
	* Where do we put logs for this script
	* Is it a feature
* 2023-07-08T20:47:55-04:00
	* So how exactly do we integrate all these meme's
	* Ummm we can use the self edge idea for the UUID's
	* Can we query Self Edges
	* Ummm self edges can have tag's right?
	* Yes Tag's can have special ID's and stuff on them
	* So how do we sort stuff in context's
	* Context's are just meme's themselves that can lookup other meme's, a type so to say
	* Alright that works
	* So we indexing everything
	* Yes
	* Which repo do we do this in
	* Well we need to check a bunch of things in the tests
	* Add them to the TODO
* 2023-07-08T20:33:21-04:00
	* Alright we writing a script to add these all to Question Engine
	* Also how do we deal with the links between memes within Question Egine
* 2023-07-08T16:48:23-04:00
	* Alright what's next?
	* Well we will have our sqlite file available in a minute
	* Let's get our Raindrop one
	* Sure
	* Dude [Raindropio](/053d3ec8-825f-40bd-b187-926273159b09) is just a single CSV, could not be easier to parse and stuff
	* Dude check the tags
	* Dude you could query the table RAW if you wanted
	* Hmm we are not there yet
	* So I guess we dump every one of the documents to Question Engine and make the Homepage and Directory one's public?
	* YES
	* Dude we need to replace all the links
	* Dude we set this up for ETL that is not a problem
	* So how do I curate my custom feed?
	* Home Feed Pintrest Style
	* Alright we can do that
	* It's going to be so cool to rewrite the backend in Rust
* 2023-07-08T16:40:03-04:00
	* Let's see what we can do for [Permissions on Question Engine](/Permissions on Question Engine)
	* Wait do we want to embed these logs into the actual logs then share them here and stuff?
	* We can do that later
	* So we have the entire PKM inside of a database right
	* Yes
	* So do we migrate that database over or leave it how it is
	* We gotta migrate it
	* Alright then what do we do?
	* We need to track the tokens and stuff
	* No we need a MEME MIGRATION TOOL
	* MEME MIGRATION TOOL
	* Ya then we can generate a hierarchy file for each group with separate permissions
	* Shit that is simple enough to work
	* What about complex group permissions
	* You can wither access then fork the meme or you can't
	* Alright so we need to get that sqlite export of my wiki
	* Alright let's go do that
* 2023-07-08T16:28:39-04:00
	* So what is Question Engine supposed to look like?
	* It's supposed to be an interface for your PKM and Raindrop
	* It's supposed to fucking replace Raindrop
	* Ya I guess
	* So what is the story of your published PKM
	* You have not thought this through
	* Shit I guess we need to go back to User Stories
* 2023-06-23T20:23:03-04:00
	* Let's add a feature to generate and store the mneomic in the browser
	* So do we just add a button to the wield_persona page
	* We can just add another button and write the function
	* Let's do it
	* Alright let's move over to artitrum
* 2023-06-23T09:18:41-04:00
	* Next is Context API end points and API user flow
	* Then we do the front end stuff
	* I seriously need a break, my productivity has dropped off a cliff
	* Where are the PERMISSIONS codified
	* Permissions are in MEME data not the transaction data
* 2023-06-23T07:52:50-04:00
	* Should we mint a context the same way we mint a group?
	* YES
	* AHHH I don't want to add another table
	* Do you want to run DISTINCT queries?
	* NO
	* Then Fucking DO IT
	* Wait it doesn't really matter
	* Let's just generate our own UUID
	* What happens when someone else uses the UUID
	* Who cares bro POC remember
	* 
* 2023-06-23T07:12:12-04:00
	* Dude go update the real Database now
	* Then impliment the transaction
	* Then test the transaction
	* Then write API endpoints to get that data out
	* Write tests for the API end points
	* Write API tests for user flow
	* Then do UX stuff
* 2023-06-23T07:01:12-04:00
	* So what types of MEME_EDGE_STATUS_CODE's do we want to implement
	* We need to add a CONTEXT_ID to the schema
	* Then we need a list of CONTEXT_CODES
	* THIS IS A POC WE CAN DO FULL TEXT CODES
	* Alright
	* So can the SUB_ITEM have a NEXT_ITEM
	* Yes
	* We need integers to track the context
	* Cool so let's add a CONTEXT_ID and a CONTEXT_NONCE
	* Do we want to call it CONTEXT_NONCE?
	* What else can we call it?
	* CONTEXT something else
	* Ehhhhh AHHHHHHH
	* CONTEXT_INDEX
	* Yes that's better
* 2023-06-23T06:53:18-04:00
	* What is the story for these edges
		* Add comments in the code bro
* 2023-06-23T06:52:36-04:00
	* I need a plan bro
	* Alright let me think for a sec
	* Impliment edges
	* Yes
	* Then dump the context via a test
	* Yes
	* Then start work on front end
	* Cool
* 2023-06-23T06:49:16-04:00
	* How are we doing to deal with the recursive questions
	* Shit, these can be types of edges
	* Imagine a "NEXT_ITEM" and "SUB_ITEM" edge
	* Ya and the context also has a UUID
	* Hmmmm so we need a CONTEXT_ID attached to an edge
	* And if we have a CONTEXT_ID we need a table for them
	* Well no we don't
	* Let's just hard write this for the proof of concept
	* Hey we can't even ad edges yet
	* We should fix that
	* Then we can dump the first context transaction
	* Dam this actually fits together
* 2023-06-23T06:46:42-04:00
	* I need something more specific
	* Like what
	* Imagine the user flow and how we display the context
	* Dude we need a context data structure
* 2023-06-23T06:42:25-04:00
	* Alright mother fuckers what are we doing next?
	* Well we need some UX diagrams, we also need that API updated for groups
	* Remember we want people to be able to answer these questions later today
	* I CAN DO THIS
	* What's next
	* CONTEXT
	* Dude UX then API
	* Alright so what screens are we missing
* 2023-06-23T05:34:40-04:00
	* The edges also function as pointers
	* If you want to access a meme you need to have an edge that points at it
* 2023-06-23T05:25:08-04:00
	* Dude giving someone a token when we remove them from a group?
	* Dude we can just assume it is zero okay
	* Alright
* 2023-06-23T04:09:00-04:00
	* Do we want to require a token transfer when doing group based stuff?
	* Yes
	* So if we give someone permission we have to give them a token?
	* Hmmmm yes why the fuck not, let's fucking do it
* 2023-06-23T03:36:50-04:00
	* What is the task right now?
	* Umm to create groups and add people via transactions
	* What about context?
	* Dude that is just a bunch of standardised JSON that we need to document
	* Alright that's be pretty easy... ish
	* 
* 2023-06-23T03:30:51-04:00
	* Alright we got our tables created
	* Dude we need diagrams to document the flow of the API
	* Yes but we already documented it
* 2023-06-23T03:20:15-04:00
	* So for our permissions and context we have our new Schema, we going to impliment it, then go write the API?
	* YES
* 2023-06-23T03:09:33-04:00
	* Alright what's next?
	* What about multiple group permissions
	* I guess we need meta groups
	* So we need a group for that
	* YES
	* Separate table?
	* Is that making things too complicated
	* Okay so think about it we have something in the published and the blog groups
	* Oh these are just tags that have groups attached to them
	* Why don't we just have RBAC tags?
	* Do we even have tags?
	* Paul think about how that would work
	* Ya I just query the edges for a GROUP_ID
	* Shit that might work
	* What about version control and crap
	* CONTEXTS BRO
	* Alright so my PKM can have its own contexts that narrow's down the search
	* Yes exactly
	* So what is needed for these permissions and stuff
	* We need the users in a group
	* We also need the group permission in the edges
	* EDGE_BASED_PERMISSIONS
	* YES
	* Alright we still need the groups table though
	* Yes
* 2023-06-23T03:01:48-04:00
	* Alright we got permissions and user stories
	* Out Groups and Context are going to need their own tables
	* Well maybe not the contexts let's take a look at that schema
	* We have the MEME status code
	* Alright so we can have a context meme in the MEME's table that makes things simpler
	* What about when people do not have permissions to see the memes within the context meme
		* Well the context meme can provide the data and the source, remember the context is just going to link the other memes that the user needs. It can be like putting together a puzzle. Or just copy the memes and their hash and stuff. Allow people to do what they want.
	* So context memes solved until implimentation
	* What about groups
	* Groups are definately going to have a UUID
	* Okay so when I go from my PKM to Question Engine how do I assign the same groups
	* Dude you are going to have a merging procedure and you are just going to look up the existing group attached to your user or whatever then work from that
	* Alright so
* 2023-06-23T02:44:15-04:00
	* Tell me what you are doing
	* We need some user stories about permissions and stuff
	* Alright what else do we need?
	* We need context
	* Wait is the links as in replies to a meme context as well?
	* Yes I would think so
	* But the context of my PKM and how it links together is different from how it it links
	* Dude these are all different types of edges, we are just labelling them differently
	* So we need context and permissions, and maybe a caching table for how many links a meme has
	* Alright what are the stories about permissions and context
	* Gotta go write those
* 2023-06-23T02:39:40-04:00
	* We wasted all our time
	* Now it is crunch time
	* It is time to build
	* What are we building
	* We need to be able to do two things
	* What are those two things?
	* Do interview's for Question Engine, and share my PKM
	* Alright what do we need for that?
	* Context Graph's, like IDK how you are going to represent the the linkages of your PKM in there
	* Nah that's easy
	* I mean the hierarchy
	* Dude you can just pull that data from the JSON raw it's now hard
	* So just generate the hierarchy in material UI like a scrub
	* YES
	* Alright that works
	* What about recording the links from the queries
	* Alright so what do we need
	* CONTEXT TABLE
	* Yes we need that
	* But how do we generate the context?
	* Dude context is like your PKM
	* No like how do we display it? 
	* Dude we can figure that out later, if we have a working API it'll be easy
	* Alright
	* So we have this context, we have this way of generating context as a sum of separate memes
	* Yes
	* And what about permissions
	* We need permissions on the edges and we need permissions on the files in the form of groups
	* We need permissions user stories
* 2023-06-22T16:36:41-04:00
	* You need something specific to do Paul
	* You need to know how your API works
	* 
* 2023-06-22T15:58:42-04:00
	* Alright so what do we do now?
	* Call Sarah
	* How do we manage permissions again
	* We have public memes
	* We have group memes
	* We have transaction memes
	* Groups are updated via a transaction... remember that
* 2023-06-22T02:12:09-04:00
	* We need a way for managing collections of memes, and tagging them
	* Dude how does Raindrop get in here?
	* Can you represent whatever is in raindrop as a series of JSON nodes
	* YES
	* Than it belongs in here
	* Okay
	* Dude you did no work besides intellectually masturbate for like two hours now
	* Ya I know and
	* STOP IT
	* Alright
	* Get away from your computer
* 2023-06-22T01:42:27-04:00
	* We have two options
	* We can dump my PKM into the existing Question Engine Schema, we can even have version control built in
	* We can even add edges to the edges for the purpose of permissions
	* So if I put my PKM into this schema how do I get it back out?
	* Let's think about index.md
	* Yes what about it
	* A new version shows up, there is a edge on it saying there is a new version
	* Well why would someone have the old page you look up pages based on UUID first
	* So you say you want the index UUID
	* Crap do we end up with namespaces?
	* No we called them context windows
	* So you have to navigate to the most recent version of index.md by recursive call
	* No dude this works like IPNS, you have a name that points to the most recent T_HASH_OF_MEME
	* So how do the links work from the most resent T_HASH_OF_MEME, let's say I click on the blog posts page, how do I get to that?
	* Hmm good question
	* Well I guess we need a naming system in here that points stuff at T_HASH's and stuff
	* Ya namespaces
	* No Context Windows
	* Namespaces
	* Context Windows
	* Ah so we have our first context window use case
	* The same way my blog turns into a context window
	* Ah that's what this thing is missing
	* So what would a context window look like in the schema?
	* So we have the root system which is memes and edges
	* The root system is like memory, we can then create context using pointers
	* How do we track how context window is created?
	* THink of user story
	* We have 10 question we like in a specific order
	* Dude that's just a query of the system, a table you could say, a series of T_HASH_OF_MEME
	* Dude make sure your API does what you need
* 2023-06-22T01:17:34-04:00
	* Hmmm is that really doable?
	* Would I trust my system that much
	* Well no I won't I would run that locally
	* What about context memes
	* Dude there is something about the transformations that is to be said
	* Ya what was that about the transformations
	* Well we have a raw piece of information then we layer context on it
	* Like imagine writing a rough draft of something
	* Then you get a hypothesis.is editing layer on top of it
	* Then you go back and change the origional article based on the feedback from hypothesis.is
	* This is the same "entity" that we are dealing with 
	* Dude that's a hard problem don't try and solve it right now
	* Wait we already have that with the MEME EDGES thing
	* Wait the edges themselves require permissions
	* DUDE YOU NEED USER STORIES
	* GET A UI WHERE PEOPLE CAN RESPOND TO SHIT
	* GET THE CARDS IN THE UI RATHER THAN STUPID LISTS
	* 
* 2023-06-22T01:14:50-04:00
	* So what is missing
	* Dude the Gitlab backlog
	* Dude by the end of Eth Waterloo you need to be able to query
* 2023-06-22T01:11:14-04:00
	* So we have a permissions STRING in the backend
	* Dude we need to treat permissions like edges?
	* Holy shit that might work
	* It should be a separate table though
	* What about federation
	* Build your dam POC
* 2023-06-22T00:33:25-04:00
	* [Conduct user surveys through Question Engine](/Conduct user surveys through Question Engine)
		* Does this user flow work with my current schema?
		* Ya our problem now is that we do not have
		* We are missing the context queries
		* What would a context query look like
		* Well a compound SQL query
		* It is like a jupyter notebook
		* SELECT MEME WHERE MEME_UUID = UUID AND MEME_CREATOR = CREATOR_DID
		* SELECT MEME WHERE EMBEDDING MATCHES VECTOR ............
		* So can I have a context that is updated
		* What was that schema that got updated over and over again?
		* So where in the Schema do we have these contexts?
		* We are talking raw queries right now
		* So what table is this going to be in?
		* Do we call these context windows?
		* I want people to write the answers out so the root issues work
		* Go to persona who asked these 10 questions
		* Interface can sort the cards however they like
		* Users can get a NFT when they have answered a specific set of questions
		* So how does context work within the current database?
		* Dude you need a building context user story
		* Dude you need to write some shit
		* Dude you have a user story already go impliment that shit
		* Do I use the old stuff or the new stuff
		* What new stuff?
		* THE PERMISSIONS BRO
* 2023-06-21T16:12:25-04:00
	* Paul go on a walk you are completely scatter brained
* 2023-06-21T16:10:12-04:00
	* We need a place to list design decisions
	* [What design decisions do I need to make for Question Engine?](/What design decisions do I need to make for Question Engine?)
* 2023-06-21T16:05:35-04:00
	* What is missing inside Question Engine
	* We already have the graph based structure
	* You should try and see if you can dump your Questions into it right now
	* So do the UID's work inside of my old Question Endine Schema?
	* Oh everything in there is hashed
* 2023-06-21T16:01:57-04:00
	* I think we need to start thinking of this in terms of the API we want
	* Like how do you query your Daemon, how do you query Question Engine?
	* Well we are going to have different feeds.
	* We have the API documented
* 2023-06-21T15:58:49-04:00
	* Alright we got our permissions schema
	* So we need a map of the repos
	* Is it time we took a look at ddaemon again
	* It is time we scheduled our vacation
	* So this permissions schema has to go into another project
	* Does it go into the origional question engine backend?
	* Ummm ya I guess we can do that
	* That's probably the best thing to do
	* We don't have time to rewrite the question engine backend
	*  
* 2023-06-21T15:47:55-04:00
	* Alright we got the user stories done
	* Now permissions
	* Wait where are those
* 2023-06-21T15:41:53-04:00
	* Alright what do we do now?
	* Meditate, dude you are too "focused" wrong mental energy
	* Dude we are going to need a blockchain git repo
	* Yes we are
	* We are going to need a raindrop-binding repo
	* Ooooo the dentropys-obsidian-publisher should be called markdown_files_binding
* 2023-06-21T14:16:37-04:00
	* So what are in note permissions?
	* IDK
	* Remove it
* 2023-06-21T14:12:51-04:00
	* Dude each of these notes require permissions attached to them
* 2023-06-21T14:07:07-04:00
	* But what are we doing in the mean time
	* Dude you know what user story we need
	* We need a queries folder
* 2023-06-21T14:00:43-04:00
	* Alright what do we do now?
	* MORE USER STORIES
	* PUBLISH YOUR QUESTIONS
	* We are missing a user story
	* Which one
	* Sending requests and verifying them
	* Alright so we need some pub stuff shit?
	* Ya IDK how to do this pub sub server crap
	* Dude this would be perfect for NOSTR
	* We scraping noster tomorrow?
	* YES
* 2023-06-21T10:57:39-04:00
	* Alright what's next?
	* Paul go on a walk, also eat something
	* What are you even trying to do
	* Umm develop something
* 2023-06-21T09:58:05-04:00
	* Alright let's just develop a schema and see where that get's us
* 2023-06-21T09:47:46-04:00
	* It's Permission's Time Mother Fucker
* 2023-06-20T23:56:09-04:00
	* We need a spot to plan out these schemas
	* Alright what's next?
	* Well we need the syntax tree stuff somewhere else
* 2023-06-20T23:50:26-04:00
	* Alright dentropys-obsidian-publisher now works
	* I am trying to get everything into SQLite
	* One issue is that the syntax-tree is a transformation therefore deserves a separate UUID
	* Do I create a separate table for the Syntax Trees?
	* I should also probably do something a little more than UUID's
	* We need URL's 
	* Dude that is just a source paired with a UUID and some metadata
	* Ya we basically got that
	* So should each transformation be in a separate table?
	* YES, that's how your keybase-binding NLP works
	* Cool than I guess we just need a bunch of different names for the transformations
	* Cool this is going to be along the lines of what [Jason Larkin](/Jason Larkin) was telling me about
	* Alright so let's go update the schema
* 2023-06-19T14:41:12-04:00
	* Alright we have dentropys-obsidian-publisher up and running
	* Yes but what is our roadmap for Question Engine?
	* No what is our vision for Quesiton Engine
* 2023-06-16T13:50:11-04:00
	* Alright what's next?
	* We work on the other project
* 2023-06-16T12:57:57-04:00
	* So I have a new angle for this project, how do I make my PKM more interactable
	* I can add RBAC using Ethereum Keys to my PKM
	* I can load my PKM into a database and play with it
	* Then I can do RBAC on it
	* So we can grow the dentropys-obsidian-publisher into QuestionEngine then integrate Mimetic File System
	* YES
	* I can make every document in my PKM something you can engage with
	* Ya basically that
	* But what do we do about my huge dataset
	* Dude if we have crypto RBAC from day one things can be great. You need the database to do queries on.
	* Oh this is very different than the question engine concept.
	* If we have all the databases in a schema then we query them via signed transaction we are doing single player question engine
	* We don't need all the data signed we need the queries and the results signed
	* Ah different paradime, and we need fucking user flow charts like fucking yesterday
	* Cool
	* So we going to develop dentropys-obsidian-publisher today
	* Let's take a look at those logs
* 2023-06-15T16:18:16-04:00
	* Why don't I put all my personal data from all these different apps in a S3 Bucket?
	* You are talking about DDaemon right now
	* I know but I need to question my DDaemon Data 
	* Oh we just sign every query being done on the daemon
	* Oh okay I can get behind this
	* Once we have the questions for my data we can query them
	* We need PKM integration or this is useless
	* That is what ddaemon-obsidian-builder is for
	* How so
	* It is supposed to get parsed into sqlite, like the entire markdown tree and everything
	* Oh ya, let's add that to the feature log
	* Done
	* Alright so what is the goal right now
	* We want to have [Kinetic Sarah](/Kinetic Sarah) do my interview thing Monday through Question Engine
	* Dude we need [User Flow Diagrams](/985139c2-5368-4e47-816e-aab0639d882e)
* 2023-06-15T16:08:27-04:00
	* I have a problem with the POC I want to develop
	* IDK what interface I want?
	* Like how you display all your questions
	* Dude just do cards and have search
	* Shit I do not have search integrated
	* Why not have a list of cards?
	* Ya that is how things work don't they
	* Infinite scroll?
	* That depends on the API you design
	* I should do pushups
	* YES do them
	* Alright what's next?
	* Dude you need an API for all your data
	* What was that tool called
* 2023-06-15T15:59:06-04:00
	* Alright we have a problem
	* What is it?
	* Who is going to use quesiton engine
	* Dude you just want someone to go through your question list and you know what they find interesting
	* Yes
	* This thing is going to be complicated
	* Yes
	* So what are you going to do about it?
	* We need to get back to core design
* 2023-06-13T13:06:56-04:00
	* Alright so what is the plan
	* No what do we need
	* We need to go interview people
	* We have the questions we want to ask them
	* Who do we go interview
	* Antone tomorrow
	* People at hacklab tonight
	* Perfect
	* What about our user stories
		* Finish them then hire someone to look at them
* 2023-06-13T12:50:01-04:00
	* We have too many moving parts
	* Dude just finish the fucking Demo rather than making things over complicated
	* Fuck I spend all my time typing in here rather than engaging with people
	* [Why do I find it so hard to engage with people?](/Why do I find it so hard to engage with people?)
	* [Who should I be engaging with?](/Who should I be engaging with?)
	* [How should I be engaging with others?](/How should I be engaging with others?)
	* Okay so the goal is to have Question up and running and dump my answers in there, see what people have answered, I want to know how people navigate my PKM
* 2023-06-13T12:30:14-04:00
	* Where is the feature list?
* 2023-06-13T12:14:26-04:00
	* So what is the user story I want to have in two weeks
	* I want to debate using a fucking dapp
	* So how is your debate going to be better than twitter?
	* Cause I can link DID's into everything, that's just sourcing
	* No because I can make points with tokens
	* I can mint a token to create a point
	* I can take their memes and move them around
	* Alright so what is missing from your prototype?
	* Write the one pager
	* You need a quest Paul
	* Alright what quest
	* Alright Paul what is your goal right now
	* To have a QUestion Engine usable by people in two weeks
	* Alright good quest
	* Check your dam user stories
	* Write more
	* Okay okay
* 2023-06-07T06:55:00-04:00
	* Alright we have framed the design challenge
	* Alright do another design thing
	* Okay
* 2023-06-07T06:10:25-04:00
	* Alright so what is supposed to be next for Question Engine?
	* We need research questions
* 2023-06-07T06:08:11-04:00
	* What conversations am I unable to effectively have?
	* Ummm what is next?
	* Try and go to bed
	* Dude this thing could be up and running in like a week
	* Ya I know
	* Go run the code you already have
	* I need a grift
	* Wait design system
	* These logs are missing stuff
* 2023-06-07T06:04:33-04:00
	* Alright so the first use case is to use it to contextualize my Data
	* Then we can add in the data and turn it into a OSINT dashboard
	* Question Engine can become some sort of interesting graph
	* I want Question Engine to evolve into some sort of system that can tell me what to do with my life
	* I want Question Engine to allow me to become my own best friend, a framework that allows me to wield the personas I need to get to the bottom of the questions I like to define myself by
* 2023-06-07T05:32:02-04:00
	* Proper design
	* Ya user stories, integrate this with the human experience
	* Why are you building this?
* 2023-06-07T05:27:57-04:00
	* Wow it has been two months what has changed
	* I migrated git to bcrypt rather than keybase
	* I still never read and highlight what I want to highlight
	* I started a tik tok
	* I got an iPhone
	* I attended complexity weekend
	* I finally have a Obsidian Publisher I am proud of
	* I have the project priority and deadline, [2023 - Blockchain Futurist Conference](/2023 - Blockchain Futurist Conference)
	* I presented my Activity Watch binding and was unhappy with how unpolished it was
	* I need a team
	* Ya you wana manage a team
	* I have no idea who I want to follow
	* There is no one to follow
	* Alright where are we going
	* We are going to do proper design on this project

## [2023-03-30](/2023-03-30)

* Why did development on this project stop?
	* I realized that the ideal user interface for a project like this was TiddlyWiki and would require features like RBAC and version control ([PerKeep](/9c7ee4a4-18d0-452d-b707-cc2decd6b425)).
	* Therefore this project would work best as a TiddlyWiki extension.
	* I already got tiddly wiki working on Umbrel via [Dentropy's Umbrel Appstore](/fcc49407-81d6-4576-8eeb-9a3b3c843f75)
	* Alright so how does TIddlyWIki become a MMORPG
	* Well how do you have a conversation within Tiddlywiki, a contextualised discord chat.

## [2023-03-09](/2023-03-09)

* 2023-03-09T01:46:31-05:00
	* Alright so what do we want to do?
	* We want to model people, what they do, what they say, what they want
	* Why
	* I want to model people and see how they relate to one another so I can relate to them
	* I like how Nistin just goes and engages with people on twitter, I bet he has cool friends
	* I don't feel alive when I hang out with my friends
	* Nobody wants to talk about the difference between Islanders and Hominids
	* Well some people do
	* Nobody wants to talk about their life purpose explicitly?
	* Alright Paul, finish what you set out to do and export a FUCK TONE OF DISCORD SERVERS
	* Then make a game of tagging the messages
	* Ya that UI will need SurrealDB
	* Alright Paul STOP there are two things we are building
	* A place where people can ask their questions in a formulaic way and engage in attention building
	* Then there is the modeling of people and how they think based on the information we have about them
	* THESE ARE DIFFERENT THINGS
	* You can still finish the Question Engine based on conversation
	* We need a set of questions
	* I have a long list of quests
	* What are they
	* [ ] Create a quests directory

## [2023-03-04](/2023-03-04)

* 2023-03-05T00:00:22-05:00
	* Alright so what are we to do with our lives?
	* How am I to get this thing built.
	* Dude we need the POC
	* Ya we can just import memes
	* No you don't "Just Import Memes" you create indexers then bridges.
	* Like we need PEOPLE and ORGANIZATIONS to manage the twitter, discord, and wikipedia data and its versious.
	* Ah yes we need to do that?

## [2023-03-02](/2023-03-02)

* Alright what are we working on in the next 20 minutes
* We are going to have a rant.
* 

## [2023-02-16](/2023-02-16)

* 2023-02-17T00:30:49-05:00
	* I need to figure out how I can index everything and put it inside question engine
	* Like I should be able to dump discord data into the thing
	* WAIT
	* Is DISCORD data just meme's. Messages with edges
	* Yes
	* Then it can go in Question Engine
	* But do I have to sign everything
	* This is some [dentropydaemon-wiki/Media/List/Snow Crash](/dentropydaemon-wiki/Media/List/Snow Crash)
* 2023-02-16T13:25:39-05:00
	* Alright we got the login and root meme creation working
	* Yes very nice
	* We should follow up with our Cardano forum post
	* Yes but what MVP do we desire
	* We don't even know how we want to integrate with the memes
	* We need to get people to manage knowledge bases
	* We have no plan for annotation
	* Yes we do
	* Dude learn SurrealDB
	* No not yet
	* We need to finish query_memes then we can prototype different frontends
	* That's the correct response
	* Then we can start doing the context stuff
	* We need stuff to explore
	* Can we pay people on fiver to do research for us?
	* 
## [2023-02-15](/2023-02-15)

* 2023-02-15T23:40:22-05:00
	* What is the next thing we do?
	* I want to see threaded conversations
	* I also want to see my memes then expand them to see the context
	* What is next in the user story
	* Well we need information to interrorgate
	* We need to graph index wikipedia
	* We need a text highlight library
* 2023-02-15T20:55:11-05:00
	* Alright so we have Mint a Meme up and running
	* We need to fetch the previous reactions
* 2023-02-15T20:46:51-05:00
	* For comments it seems like the best thing to do is do it manually
	* Just choose like 1% of the screen and move it over
	* I also need to processes the data structure accurately in a nested fashion
	* Shit this is gonna need restrictions and a way better API
	* Glad to see you thinking ahead
	* I want to finish MINT_MEME thing
	* We still require the transfer of one token
	* This is only Root Meme silly
	* Should users be able to spend another persons token on a root me
	* Of course they should
	* Does it need to be rendered in the UI though
	* NO
	* Good so add a int input
* 2023-02-15T20:32:38-05:00
	* What's next?
	* Well we can mint all these different tokens
	* Yes why yes we can
	* We can't mint meme's yet, we can see the meme's can we
	* Let's check
	* We have a bunch of errors with the API
	* Yes I see
	* Let's fix those and then do that other thing I am supposed to do
	* Nothing wrong, I am just using the same seed in metamask as I do for the tests
	* Alright what now
	* Remember the user story
	* So after we mint a token
	* We mint meme's, ROOT_MEMES
	* Gotta work on that modal
	* Okay we can work on that modal
	* Also I want to research a react threaded library thing like reddit or hacker news comments
* 2023-02-15T20:29:31-05:00
	* Alright at this point we should use the cookies to login
	* Why we can do transactions we can actually start conversing
	* After we finish query_memes stuff we have in the backlog
	* No let's do that later this is for UX praise UX
	* So we fixing wield_persona
	* Yes
* 2023-02-15T20:20:13-05:00
	* What are we doing again?
	* We are doing the quest_log
	* Dude let's fix that App_bar first
* 2023-02-15T20:13:55-05:00
	* Alright this MetaModal works what now
	* We do not want all these buttons such as State exist
	* Bro you don't get it
	* We can not activate the modal on any page no problem
	* Actually we can build this modal into the app by wrapping it just within the context
	* Shit would that actually work
	* Try it
	* Well maybe if we put the context within main.tsx rather than App.jsx
	* Alright so we have our ability to create a modal anywhere
	* Now what are we going to do about it?
	* Okay so the user logs in right
	* Yup they login
	* So should we have them state they exist or not
	* Well this can be part of fetching the quest_log cause that is the main page
	* YES
	* Let's save the code
* 2023-02-15T20:03:21-05:00
	* Well the meta modal works even if it is not the best way to do it
* 2023-02-15T20:01:49-05:00
	* Alright
* 2023-02-15T19:53:52-05:00
	* The modal does not render
* 2023-02-15T19:48:58-05:00
	* Wait do we want a meta modal or a modal contents.
	* They let's follow this thinking through
* 2023-02-15T19:39:39-05:00
	* How can we create a generalized modal for all pages
	* Well that would have to be a component with its own state
* 2023-02-15T19:36:55-05:00
	* Of shit I can't close a modal within a modal.
	* Fuck do we hijack context
	* Yes
	* We should have a modal context.
	* active_modal
* 2023-02-15T19:35:07-05:00
	* Alright what's next?
	* Hmmmmm
	* We can mint but we don't do anything with the result once we have it
	* Well if the result is SUCCESS we should close the modal.
* 2023-02-15T19:06:05-05:00
	* Transaction Sucessful, it was evm_address formatting
* 2023-02-15T19:02:06-05:00
	* Why the fuck can't I register a user
	* Dude debug correctly
* 2023-02-15T18:23:32-05:00
	* Seems like we have a serious design flaw
	* You can't just register without already having an account how are USER_T inserted
	* Tell me a story, how does the pseudonym get into User_T
	* Wait should people mint a token before signing in.
	* Shit that's a good idea
	* Ya we should do that
	* So on the first page if there are no transactions we ask them to sign in
	* So the first thing you do is mint a transaction, you interact with social graph / blockchain
	* We also have the what does keybase call it?
	* Like temp something,
	* [dentropydaemon-wiki/Software/List/Keybase](/dentropydaemon-wiki/Software/List/Keybase) oneshot
	* Oneshot identities
	* That's a feature to add to the gitlab 
* 2023-02-15T17:04:13-05:00
	* Alright what are we doing
	* Why minting the token of course
	* So we pulling the username from the context or the API
	* Since this get's rewritten let's pull it from the API so it matches the tests
	* Alright, makes sense
	* What's next?
	* How do we want the modal to look like
	* How about we just add in another of the modal already on the your_persona page
	* Or do we want it on other pages, like we can check the balance of the user
	* The inside of the modal definately needs to be a component
	* So let's create that component and put it inside a modal on the My_persona path
	* Sure why the fuck not
	* 
* 2023-02-15T15:34:07-05:00
	* Alright what story are we supposed to use here.
	* So what is the processes 
	* What was that
	* Alright back
	* Oh ya I remember, our Persona class did not fit into the context
	* It should really be in context
	* But then it is not modular
	* Also we want MVP, you are going to have to rewrite this two more times anyways
	* True
	* PAUL what is your goal
	* Post a question
	* Good no put that up somewhere in bold letters
	* So we need to mount the Perosna object from context
	* We should create a MountPersona class
	* Dude just code, stop over optimizing
	* So we mount our persona, then we can useState where needed within react to get the question data
	* Do we want to confirm this
	* No that is what metamask is for
	* What is required to mount a persona
	* Look at the tests yo
	* So we grab the pseudonym ,wallet, and URL path
	* Wait we actually only need the addresses
	* Yes we take the address, lookup the persona
	* Oh shit we need to mint our first token before we can do anything we need to do that
	* Hmmmm back to the user stories
	* We need a special modal
	* What does it say? [Empty Personal Wallet Popup](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/Components/Empty%20Personal%20Wallet%20Popup.md)
	* So we need to code this other modal and activate it using useEffect
	* Perfect can I go on a walk now
	* Sure
* 2023-02-15T15:22:28-05:00
	* I need my QuestionEngine.TLD's
	* Purchase complete
	* Name server forwarded
	* Alright what's next?
	* Alright what's our MVP story
	* User signs up and goes to ask questions
	* Yes
	* So where do they ask questions
	* Oh ya we wanted to redesign the UX
	* We are too noob for that this is too basic
	* So when a user goes to My Persona they should see a threaded conversation with the ability to sort everything
	* Or should we call it My Memes, or Manage Persona
	* Manage Persona makes more sense
	* Alright we can do that later
	* What was this update persona button here for?
* 2023-02-15T15:10:28-05:00
	* Bro get the code out
	* Alright the code is out
	* What's next?
	* We need to prioritize the user stories rather than looking at them all
	* Alright do we want to do
	* I want a automatically signed in user for testing purposes
	* No reread your user stories, make sure they make sense
* 2023-02-15T14:57:05-05:00
	* Alright where do we start
	* What is your goal
	* Let's get the code up and running again

## [2023-02-08](/2023-02-08)

* 2023-02-08T13:52:38-05:00
	* Alright we are completely migrated to Gitlab and archived the old TODO list
	* Alright you gonna work on your user stories mentioning [dentropydaemon-wiki/Software/List/Heptabase](/dentropydaemon-wiki/Software/List/Heptabase)
* 2023-02-08T13:28:47-05:00
	* Alright we moving to git lab where we can manage issues better
	* Ya let's do it
* 2023-02-08T09:06:18-05:00
	* Alright what should the TODO list look like
		* Make sure query_memes is scoped out and tested and works for transactions
		* Move forward with cookie and Persona class integration
		* 
* 2023-02-08T08:59:47-05:00
	* Alright make a better TODO
	* We need an actual ticket thingy
	* Ya we do don't we
	* We can do it all in Obsidian
	* No it should be done inside git
	* Alright so we doing Github private repo
	* I don't want my work to see this
	* Gitlab then
	* Sure why not
* 2023-02-08T08:50:02-05:00
	* We accomplished nothing
	* Do you have greater clarity and awareness
	* Sorta
	* No tell me what your plan it
	* We need to have those queries built into the query_memes API
	* Good what else
	* We are just going to create a Persona class on every page, maybe store the data in the cookies
	* Good so we can use Persona, we can also query our memes
	* What else is missing for your POC
* 2023-02-08T08:47:05-05:00
	* Done
	* What now?
	* Okay okay okay
* 2023-02-08T08:45:29-05:00
	* Alright we got our filters, we are cheaping out on the ContextProvider
	* Alright what's next then
	* Do we commit our code.
	* YES 
* 2023-02-08T08:34:22-05:00
	* We are all about measuring activity
	* Dude choose 5 simple filters
		* Chronological / Reverse Chronological
		* Most Replied (Total Memes)
		* Most in depth conversation (Total Memes / People)
		* Most linked (Can't do this now without MEME_EDGE)
		* From Persona
		* Meme Type
		* Longest Meme
* 2023-02-08T08:33:35-05:00
	* What are we looking for?
	* Good question
	* We are looking for ummm
	* The queries
	* Found them
* 2023-02-08T08:30:22-05:00
	* Stop moving papers around
	* How do I know about that analogy
	* Cause it just makes sense
* 2023-02-08T08:24:45-05:00
	* Alright so we need this shit scoped out
	* You say FILTERS
	* What do you mean by that?
	* What filters do you want on twitter
	* I should write an essay about this
	* No think about it
	* We found these yesterday
	* WOW it takes this long for me to remember what I did yesterday
	* THIS IS WHY YOU LIFE LOG IDIOT
	* The hypocrisy knows no bounds 
	* Alright alright alright
	* Where is it
* 2023-02-08T08:19:36-05:00
	* Alright what's next?
	* We had a bunch of things to fix
	* Maybe we need to go on a walk and get some energy
	* Ya
	* No WORK
	* Our wallet and access token are stored as cookies we can leave them there
	* Alright
	* The persona object would need to be translated into a context
	* We can create a context object any where any time
	* Shit we are taking so many short cuts
	* Dude just create a Persona everywhere you need it
	* That's not correct code
	* Then upgrade MetamaskProvider to work as a Persona
	* That would make sense
	* But you need this to manage like dozens of personas
	* Ya let's just load up the Perona class everywhere, we probably want to use IndexDB
	* Oh ya we had to do the UI stuff
	* Dude get that TODO list open


## [2023-02-07](/2023-02-07)

* 2023-02-07T16:06:13-05:00
	* Still have not gone on walk
	* Check this out later, [Keybase Binding Queries](/da8ee43f-5075-4547-a583-65a941185d4a)
* 2023-02-07T15:31:15-05:00
	* Let's reprioritize
	* We are not here to reinvent the wheel
	* We just want a more approchable social media with fine grained control and 1990's internet vibes
	* Right now we just want to replicate twitter with a bunch of filters, maybe we can even feed twitter data into the same thing
	* Cool project bro, now focus
	* So we wana see memes like in twitter, we wana respond to them via prop injection modal, we wana see our meme's
	* Do we want a query_memes page rather than discovery
	* Dude stop changing things, twitter has a profile page doesn't it
	* Yes
	* Does it use the same components as the feed generator
	* Yes
	* Cool now just have a bunch of cards and a card feeder
	* How does react do infinite scroll
	* Infinite scrolls looks pretty easy
	* Alright so you got your feed thing nice
	* Your my_persona page will also be a feed with filters
	* Nice
	* The reply button has a modal where any of the valid transactions can be done
	* We have a crypto wallet remember
	* Well we want this on a real blockchain eventually
	* Ya so just the same cards via query_meme API
	* Well different cards but still query, or table fuck it who cares this is POC
	* Alright so you will be able to look at memes with filters, respond via modal, go to my_persona apge, do similar filters but also have a MINT_ROOT_MEME button
	* That seems simple enough
	* I feel like something is missing
	* Can we have a conversation with this system?
	* We don't have reddit threading
	* That can be a filter type added in quickly
	* Alright so there is responding to a meme, easy a modal shows up
	* But what about when we investigate a meme?
	* Ya what happens when we investigate a meme?
	* So we click on it, do we stay on the discovery_page
	* How about we go to meme_interrogation page
	* I love the symbolism
	* No contexualize endpoint
	* So /contextualize/MEME_ID
	* Then we can see separate filters
	* When we go back we go to discovery
	* Hmmm that seems to work
	* So when we select a persona we get /persona/PERSONA_ID
	* Yes that works for me
	* I feel bad cause all this does is replicate twitter
	* No it doesn't we have the transactions that reveal stuff that people can look at via filters
	* Oh ya, twitter does not have filters
	* Imagine you are just creating a better twitter with filters
	* How many twitter filters would I want ideally
	* You know you can just use twitter filters via the advianced search
	* I am an idiot ha ha ha 
	* I need to find what these filters are
	* YES YES YOU FUCKING DO, your query_memes sucks bro
	* PAUL, you already did this with Keybase queries
	* Let's find those
	* [Keybase Binding Elastic Queries](/d3b690e2-60fc-4bbc-b90b-1ca72360b64c)
* 2023-02-07T15:08:22-05:00
	* Alright at this point we might as well generate the transactions raw
	* Nonononono if you have a Persona provider they can hold hard coded data
	* Oh ya we can use the internal data and hard code a bunch of shit
	* Can we store async functions!?!?
	* Let's google this
	* We may need a walk to figure this out
	* Paul what are you trying to do?
	* What is your goal
	* I just want it to be easy to send transactions from every screen
	* You know you can store the nonce and previous_transaction_hash as a cookie
	* Well ain't that cheating
	* It works tho, and it is how cookies are supposed to be used
	* I doubt that this is how cookies were supposed to be used
	* Cookies just have the one main ID
	* Dude just do it this solves your problem easily
	* We can also fetch the previous nonce and transaction hash every time we want to do a transaction
	* Well wooptiedoo
	* Dummy Paul
	* You are my puppet now
	* That would be nice
	* Who was playing [Paul Atreides](/Paul Atreides)
	* Alright what's next?
	* We need to rethink the application
	* How so?
	* I should go skip rope
	* Dude this is not the place for this
	* Who cares, I bet no one is gonna read this
	* You are probably right
	* You think you are so god dam important
	* Alright back to work
	* ALright so we can generate the transactions everywhere we go based on inputs
	* WAIT WAIT WAIT
	* Where are we doing transactions!!?!?!?!?
	* We have this BURN, MINT, MEME, MEME_EDGE, TRANSFER
	* Dude you are fucked, you need to diagram this shit
	* Your user stories are horrible
	* Shit bro I am fucked
	* Yes now you are learning
	* Alright so what now?
	* I just want to be able to post memes, look at memes with filters
	* I want the filters to be a button with a modal
	* How do you feed data back from a modal?
	* The modal can be inside the same component
	* Ahhhh that makes sense
	* Overoptimization means death
	* I like thinking about this problem
	* Over Optimization Means Death
	* No the feedback from components in react
	* That's now how react is supposed to work
	* Dude this is literally what the Context API is for
	* Alright alright I already know how to get around this
	* So my screen suck
	* What is that free Figma thing
	* You mean [dentropydaemon-wiki/Software/List/Penpot](/dentropydaemon-wiki/Software/List/Penpot)
	* Ya no [dentropydaemon-wiki/Software/List/Miro](/dentropydaemon-wiki/Software/List/Miro) is the way to go
	* Miro is such a good name
	* Alright so what is the next steps?
	* Walk obviously
	* Alright what are you going to think about on the walk
	* The provider, screens, user journeys
	* Wait we should use Brave as our reference model
	* Brave get's installed and you can transact with anyone
	* Ah you make your own friends list in Quest(ion) Engine
	* So we need a modal that can send stuff
	* Ya we need modals for all the different transactions
	* And these modals can all take props
	* When you use twitter do you click back and see your reply?
	* No but you get a popup saying see tweet with a link
	* How does brave do it
* 2023-02-07T15:06:04-05:00
	* Alright Paul are we rearchatecting the entire application to use a Persona Provider
	* Wait wait wait
	* We just need to replicate the get and set stuff
	* Metamask was already holding the data
	* The other functions within the Persona class can require all inputs, for example we can now skip the default input and stuff
	* That is going to require a crap tone of inputs
	* Well transactions are holding a lot of data
	* Alright that works for me
	* Let me take a look.
* 2023-02-07T15:00:24-05:00
	* Shit bad news bros
	* I think the context API requires functional stuff, so it needs to return itself
	* Well let's try this first
* 2023-02-07T14:41:17-05:00
	* Oh ya we are supposed to use our Persona
	* Yes
	* Now are we going to mount it inside the context?
	* I mean we should
	* At what point do we put it within the context?
	* Also can we update it?
	* IDK and do we care?
	* Yes we need to be able to update it
	* So this should be done within wield_persona
	* Do we call it PersonaProvider now
	* Paul this git commit during work is causing too much cognative load
	* Altight can I change them later
	* Who cares about the git commits, post the code without git history and tell people they can have it is they ask.
	* Alright
	* It seems pretty easy to change, [How can one change the timestamp of an old commit in Git? - Stack Overflow](https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git)
* 2023-02-07T14:20:34-05:00
	* So what should My Persona have?
	* A series of cards that have My Meme's
	* Sort by permissions, type, root_meme's etc.
	* How does this relate to discovery?
	* my_persona is just discovery but only my memes
	* Do we want to lump this in with discovery
	* All apps have a profile page, you can lookup your profile by search and come back to it
	* Ahhhh you see we need to have the same components for viewing a persona that we have to manage our own persona
	* So how is this supposed to work?
	* Well why don't we get out Mint Meme component working, and have it take in props n shit
	* Hmmm yes, but what modal do we want to use, react_router or material ui?
	* Well on social media you respond inside the meme
	* To create a new post you don't
	* Alright you wana embed it think it though
	* You can have a component
	* Paul what are you replicating, twitter, reddit, facebook, or instagram
	* It is definately a modal with the cards above
* 2023-02-07T14:17:17-05:00
	* Oh shit we got the discovery all backward. We are supposed to list the active users.
	* Do we want to discover MEME's or PERSONA's
* 2023-02-07T14:13:36-05:00
	* Alright we got basic meme viewing functioning
	* Ya but that formatting
	* Do we just wana show tiles or something like they do in marketplaces?
	* Ya we defiantly want cards
	* We commiting this code
	* No let's create the memes via your_persona
* 2023-02-07T13:51:52-05:00
	* Alright we need to be able to set the no memes thing by default
* 2023-02-07T13:44:09-05:00
	* Alright what's next?
	* Why we need to display the meme's
	* Yes, then what?
	* We need to be able to post the memes
	* Alright so we do /discovery then we do /my_persona
	* Alright let's finish up discovery
* 2023-02-07T10:09:34-05:00
	* Next step is CSS refactoring
	* Watch a "CSS in Minutes" video on youtube
* 2023-02-07T08:35:14-05:00
	* Alright what's next?
	* Do we want to share meme, see other's memes, or my own memes
	* It would be nice to see other people's memes
	* So we just going to query all public memes chronologically
	* We need to play the game to challenge the rules and that is the twitter game
	* So we doing this in discovery
	* Ya we will eventually have tabs there for like users, post type and stuff but
	* So do we have the query_memes query_type for public chronological
	* We need a a graphql guy
	* We need to have a better generated dataset
	* We can get a bunch of friends and do a miro board
	* YES
	* YES 
	* YES 
	* DO THIS
	* PLEASE DO THIS PAUL
	* Alright now query_memes
	* Assign yourself a quest
* 2023-02-07T08:33:48-05:00
	* Alright what's next?
	* Take control of your life
	* Besides that
	* Dude stay in control
	* I am fine
	* No you aren't
	* We posting this in my public valut?
	* Sure why not, I just feel lonely
	* Is that all you feel
	* I feel like I am wasing my life
	* Alright we can deal with this later, we will remove these logs from there eventually
* 2023-02-07T07:49:16-05:00
	* Alright what's next?
	* Hmmmm
	* Why frontend stuff, let's take a look at these memes why don't we
	* Alright we can still login, but are we using the access_token correctly?
	* No, do we even have it stored as a cookie?
	* We need to rewrite the login flow
	* Why
	* Cause it still assumes cookies
	* Alright so what you just going to get an access_token and save it
	* YES
	* How do you validate it?
	* We can add a API endpoint for that easily
	* Alright so the frontend should check for a cookie then go to question_log 
	* So we storing the cookie as JSON right?
	* Yes
	* JSON Object, like with the persona and key
	* Ya
	* So like this
		* Persona
			* pseudonym
			* evm_address
			* access_token
	* Yup
	* And wield_persona is supposed to set this
	* Yup
	* Alright I can do this
* 2023-02-07T06:04:16-05:00
	* Alright we have the MEME's being minted by PERSONA
	* Alright what's next?
	* We do frontend now right?
	* What do we do in the front end?
	* We create an interface to query, respond to, and mint memes
	* Good
	* Go on a walk bro, get a nice coffee brush your teeth
	* Alright
* 2023-02-07T05:29:27-05:00
	* IDK what I even have the previous personas converse let's add that to the front end
	* No we need to post memes
	* What memes
	* So we need to spend our own token to ask questions
	* Alright so everyone asks a bunch of questions
	* Yes and then we can get the frontend to answer them
	* Alright
* 2023-02-07T05:13:37-05:00
	* Alright what do we want this conversation to look like?
	* We have the example conversation
	* We should adopt our persona names then
	* Ya we should
* 2023-02-07T04:55:17-05:00
	* Alright what are we getting done today
	* We are going to add the MEME transaction to the Persona class and get started on the frontend
	* How do we want to do the frontend
	* Is there a simple markdown package?
## [2023-02-06](/2023-02-06)

* 2023-02-06T06:26:46-05:00
	* Are we going to keep working
	* Working on what
	* The meme transactions then upgrading the frontend
	* 
* 2023-02-06T05:34:53-05:00
	* The next thing should be to create meme and meme edges
	* Wait the backend code for meme edges is not written
	* MEME_EDGES and CONTEXT are outside scope for POC
	* Alright I can accept that
	* So are we going memes or having a break
	* The fact you need to ask signals you need a break
	* Do I go on a walk
	* Just lie down and listen to music
* 2023-02-06T03:54:03-05:00
	* Shouldn't we use an object for tracking previous transactions in general
	* A users transactions stay with their persona
	* Alright I can agree with that for now
* 2023-02-06T03:34:21-05:00
	* Alright what's next?
	* Why we need to be able to what exactly?
	* How do we want the API to work for transactions
	* Do we just want MINT, BURN with inputs
	* Or like TRANSACTION_MINT
	* Or have a PERFORM_TRANSACTION with different types
	* No separate methods that is easier
	* GENERATE_MINT_TRANSACTION
	* SEND_TRANSACTION
	* That works
* 2023-02-06T03:22:13-05:00
	* Alright so what is the plan?
	* We MINT twice, then we transfer, then we remove, and we burn
* 2023-02-06T03:04:00-05:00
	* Alright what's next?
	* We need our PERSONA class to be able to do all the different types of transactions
	* Yes then what?
	* Have a conversation using the protocol
	* Then frontend
	* Alright break down the task more
	* Do we redo all the tests we already did
	* YES, we are going to have to
	* So we MINT, TRANSFER, REMOVE, USE_FAUCET, MEME, and MEME_EDGE
	* Alright what else?
	* So do we just have inputs and have the transaction do it's own thing
	* We also gotta index the meme's and stuff for a persona
	* Do we want a list of ACCESS_TOKEN's
		* Later think simple right now
	* Alright so we redo all these transactions 
	* In a single set of tests
	* YES
	* Then you worry about query_memes
	* Cause you will have the ability to create tones of them
	* Alright I can do that
	* Do we need to keep the access_token in the constructor
	* NO
* 2023-02-06T02:20:33-05:00
	* Do I want to go on a walk and get a Burger
	* I mean we probably have some pretty good leftovers in the fridge.
* 2023-02-06T01:45:53-05:00
	* Alright what's next?
	* You know you should put a description of the top of each test to say what it is for
	* You know that is a good idea
* 2023-02-06T01:35:51-05:00
	* I am running out of time
	* You always have been
	* Finish this shit, what are you waiting for
	* What do I need next
	* You need to be able to query the memes, pay for a meme, then reveal the meme
	* Alright we need to do these tests
	* Yes this is POC you can pay for code review after
	* No I need something more specific
	* Get the 5th test working

## [2023-02-05](/2023-02-05)

* 2023-02-05T21:56:39-05:00
	* Alright what are our next steps?
	* Hmmmm
	* We have helper functions for all the different transactions and querying everything
	* Then we develop QuestJournal
* 2023-02-05T20:59:34-05:00
	* Alright we got some shit done
	* We now have this Persona object that will work in the front and backend
	* Good
	* Now you going to write helper function
	* Helper functions for what
	* Fetching what tokens I have
	* Yes what else
	* No scope that out
	* No I can answer that
	* We need helpers for all the different transactions
	* Yes
	* What else
	* Helpers for query memes
	* Oooo what do we call the client side question engine
	* Question Instance
	* Meaning Producer?
	* Human context?
	* The thing that manages the memes and stuff
	* MyContext
	* Dude context sounds like react we can't use that
	* Hmm question_instance
	* No
	* quest log
	* quest_journal
	* OOooo I like that one
	* So you use the QuestionEngine to load your QuestJournal
	* Hahaha I like this
	* Is QuestJournal really what we want to call it
	* Well this is a protocol for conversation and thinking
	* But you can't think without a quest
	* Whahahahah QuestJournal
	* So what does Quest Journal do?
	* It generates persona's and attaches memes to them
	* So what will the QUestJournal do
	* ALlow you to wield and index your Persona and Contexts
	* Also obser other Peronas
	* So we need to fetch what tokens this user has
	* Yes how do we do that?
	* Now we need to get their tokens and balances
	* Then get all their memes
	* 
* 2023-02-05T20:30:41-05:00
	* Alright seems like the test was sucessful
	* What now?
	* Why we do something
	* Do what?
	* We need to start using the PERSONA thing
	* Oh ya we can now use that in the query_memes method and stuff
	* Cool do it
	* We need all our pseudonyms in a list
	* Wait we can just call the pseudonym from the backend now
	* Oh ya this should be easy now
	* 
* 2023-02-05T19:08:50-05:00
	* Alright we got some problems to solve
	* What are they
	* We don't use cookie, we just login and get an access token
	* Shit that's true
	* So we just having a login endpoint
	* What is simpler
	* Login is simpler
	* So we updating the first tests
	* We need to update the wield_persona API bro, it has to do what get_cookie does
	* Alright alright let's do this
* 2023-02-05T04:45:24-05:00
	* We removing cookies!?!?!?
	* Well we want multiple access tokens to be available within the UI
	* So yes let's do it
* 2023-02-05T04:39:25-05:00
	* I think we need a diagram
	* No you just need to write out the steps
	* We get cookie, but now we recieve JSON
	* So fix the backend API
* 2023-02-05T04:05:00-05:00
	* VERIFY_COOKIE is actually fine, it takes in the BEARER_TOKEN which is what we want
	* So we gotta run the function with a different input
	* Now to remove all cookie verification, and pull the data from the result
	* So if no cookie is set the response does not go through
	* Looks like it
	* That's fucked
	* Fuck this, no cookies that made things too complicated
	* ACCESS TOKENS is the way to go now and I can save them in a cookie on the frontend
* 2023-02-05T04:01:19-05:00
	* Would this API work better with a JSON ACCESS_TOKEN
	* YES
	* Then get on it bro
	* Shit
	* We should diagram this out
	* I don't think we need to
	* We have the cookie checking script, now we just check for access token
	* For the get_cookie we already return JSON with the access token so we should be fine
	* Alright so get_cookie is fine as an endpoint 
	* But verify_cookie needs some help
	* YES
	* So we adding an additional field to all the JSON
	* yes
	* MY_TOKEN
	* sure why the fuck now
	* MY_ACCESS_TOKEN
	* Even better
* 2023-02-05T03:58:03-05:00
	* So do we want minting functions and stuff now, helper functions for everything
	* Well we do want to be able to mint memes and transfer tokens easily
	* Cool
	* So what next?
	* Our goal here was to query the memes that we paid for
	* Hmmmm
	* We have not gotten there yet
	* We also stopped using cookie verification
	* Hey it should be working
* 2023-02-05T03:55:33-05:00
	* The Persona class seems to be up and running
	* Good but it is not finished yet
	* How so
	* You need to be able to do actual transaction brah
	* So should we do a class extension and stuff
	* No later, over optimization
* 2023-02-05T03:39:08-05:00
	* What is a better way to get transaction count
	* Lookup user like the other posts
	* Alright that works
* 2023-02-05T03:12:48-05:00
	* Alright we found an issue
	* We have the BEARER_TOKEN in AUTH_T getting attributed to user that do not exist
* 2023-02-05T02:45:20-05:00
	* Alright we can now check if a persona exists and what its pseudonym actually is
	* Yes and their public memes
	* Yes
	* What about their paid for memes
	* We will get to those
	* Alright what's next!?!?
	* We want to be able to query the memes that were paid for
	* 
* 2023-02-05T02:28:50-05:00
	* Alright my plan to have a class update all by itself is not working
	* What are you going to do about it
	* Well I can't do data requests within the class while saving to the class
	* You can set data within the class by calling the class
	* I guess that is going to have to work
	* So we are going to want to query the other API's
	* Nah not really
	* So we are going to run the audit thing
	* Yes but how do we update the data
	* Where could I find an API that works the way I think it does
	* Does EthersJS fetch data while updating data
	* No not really
	* So I will have to set the pseudonym using the getPseudonym method
	* Alright that works
	* Then we can have isValid just return true or false but not save it
	* Alright that works
* 2023-02-05T02:01:46-05:00
	* What do you do when you know something exists
	* valid
	* 
* 2023-02-05T01:28:48-05:00
	* Alright we can login after we forget out Pseudonym
	* But use the persona class
	* Alright I will do that next
	* How do we have this class reusable?
	* We allow setting a cookie, and the URL
	* Alright fuck it
* 2023-02-05T01:10:36-05:00
	* What do we want to call the query for NONCE and TRANSACTION_HASH
	* MY_LAST_TRANSACTION
	* sure why not
	* So how do we put on a persona when we forget our name
	* Well we create a persona class, a  EGREGORE type, then we can change it to WIELDED
	* Alright
	* Let's create this class
* 2023-02-05T00:42:21-05:00
	* Alright we coding this shit?
	* Sure why not
	* Alright get to work
	* We have like 4 hours
	* Yes we do, you can finish this
	* Alright I want to use the persona thing in the backend and test it
	* Alright what is our goal here!?!?!?
	* Ummm how about we use this persona thing to mint tokens and do transactions and stuff
	* so we can have the Persona class and WieldedPersona class
	* Sure why the fuck not
	* So a Persona class with contain that users memes and other data
	* So how do we use this class
	* Well we don't have the query_memes stuff up and running
	* Alright let's use it for that
	* How so
	* Let's start with reverse pseudonym lookup
	* Cool we can do that
	* Alright do we want to do query_data or have the JSON have the query itself as a key
	* How would graphql do it
	* It would do query_data
## [2023-02-04](/2023-02-04)

* 2023-02-05T00:42:11-05:00
* 2023-02-04T21:09:58-05:00
	* Alright before we go on a walk how are we testing this shit?!?
	* Like if we develop this, how do we load the test data
	* Via the tests dummy
	* But the backend readloads whenever we change some files
	* You can run all the tests bro no problem, if they take like 10-15 seconds we may want refactor some things
	* Alright that works for me
	* We going on that walk now
	* Sure why not 
* 2023-02-04T19:50:58-05:00
	* Alright how do we want to manage these Personas
	* What role do they play in our project?
	* Hmmmm
	* They are the backbone of the data that get's fed into Gun.js
	* Okay so we store their memes and stuff
	* So when we create a persona
	* We have two types of persona
	* LOGGED_IN and EGREGORE
	* So we have to articulate the type
	* We do not have LOGGED_IN we have WEARING and EGREGORE
* 2023-02-04T19:40:51-05:00
	* [POST query_memes](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/API/POST%20query_memes.md)
	* Alright what do we do with this?
	* Hmmmm
	* Why not complete it
	* Out tests may need to be rewritten
	* No just add more just much much longer with helper function
	* What helper functions
	* IDK like a class that tracks the previous transaction hash, nonce, or otherwise fetches it
	* Dam that would be useful
	* We also need to fetch the user Persona
	* Do we want to write that right now
	* Ya I think we do
	* So how does this class work
	* Why it has some JOSN
		* Class Persona
			* persona_state
				* LOGGED_IN
				* EGREGORE
			* get_nonce
			* current_nonce
			* get_previous_transaction_hash
			* previous_transaction_hash
			* get_pseudonym
			* psudonym
			* address
			* signer
			* tokens_owned
			* token_balances
				* *token_name* : value
			* previous transactions
				* *nonce* : meme and stuff
	* Wow that get's complicated fast
	* Alright you writing this class!?!?
	* Sure why the fuck not
	* Wait is this shared with the frontend and backend!?!?
	* Yes of course
	* SHIT that should be another package then
	* Dude too complicated,
	* Put it in the frontend so it can be bundled and just import it into tests
* 2023-02-04T19:32:42-05:00
	* Alright what is our goal tonight?
	* Why it is to get the first use case of the question engine up and running
	* What is that?
	* Why it is to have a simple user flow
	* User signs up
	* User submits public questions
	* User answers questions, but they require payment
	* Other user signs up and pays
	* Capacity to have contextualised conversation
	* THAT'S IT
	* Alright what's stopping you from accomplishing this?
	* Well we lack the query API
	* We don't have a modal to ask questions
	* We can't query our last transaction easily
	* So you need to be able to query the memes better
	* Yes
	* Open up the docs then
	* What docs

## [2023-02-02](/2023-02-02)
* 2023-02-02T04:56:07-05:00
	* Alright how do we meme this into existence
	* We need to be able to query the last transaction
	* Do we want to have a query_transactions and query_memes
	* Transactions are memes and we want to use graphql so do query_memes
* 2023-02-02T04:24:24-05:00
	* Alright how are we doing My Persona
	* We need a mint a meme modal
	* How best to manage a modal that is reusable?
	* How do we want to manage this state? We can have the modal on every page
	* That would be stupid
	* We have the modal manipulation code separate from the modal?
	* We need a form
* 2023-02-02T04:17:07-05:00
	* Alright we merged the codebases
	* Cool now add in the question log data
	* Alright do people post a meme?
	* No what terminology do we want to use?
	* Make a meme
	* Spread a meme
	* Communicate a meme
	* Build a meme
	* Transact a meme
	* Claim a meme
	* Mint a meme
	* MINT A MEME
	* It is sorta cringe
	* Would people use that IRL
	* No
	* Is it the correct symbolisim?
	* Yes
	* Create a meme
	* Post a meme works the easiest
	* Will a meme
	* Generate a meme
	* I like generate
	* Forge a meme
	* You forge a meme with your persona
	* You forge context
	* You construct a meme
	* Let's use MINT a meme
* 2023-02-02T03:51:15-05:00
	* Alright what's next?
	* Hmmmmm time to think
	* Can we do the frontend!?!?
	* Sure
	* What part of it
	* Shit we need to do the other transaction query endpoints
	* Is this project exploding with complexity
	* If you need to ask you already know your answer
	* Focus what do I want in the your_persona
	* My persona is a series of context's
	* We do not even do context's yet
	* I know
	* So what goes there
	* That person's transactions
	* Paul you user stories suck
	* Ya
	* What is the goal of this project anyways.
	* Well let's go answer that
* 2023-02-02T03:28:51-05:00
	* Found a bug there are two entries in the balances table
	* How did they get there?
* 2023-02-02T02:52:09-05:00
	* Alright we can add response to meme now
	* We should not show user the quest log
	* No we should we just need to show context's they are working on
	* What does working on a context look like?
* 2023-02-02T02:39:06-05:00
	* We have a problem
	* What is it?
	* What were our decisions on meme edges
	* Did we not want to reference the root meme, what about what the meme is a response to
	* Ideally the meme would just have a bunch of edges built in that we could add in
	* We are currently now adding edges are we?
	* So do we want to input what meme we are responding to or start using edges?
	* We need the response meme column we decided edges were beyond POC
	* We need an example to test
	* 
* 2023-02-02T02:01:53-05:00
	* How do we fetch memes with permissions
	* How are we displaying revealed memes?
	* No we query them
	* Alright what are the query_types
* 2023-02-02T01:55:09-05:00
	* Alright time to get to actual work
	* How so?
	* We need the question log page
	* No we need to update the API then move the react code over
	* Oh ya that would make sense, keep them in sync with one another
	* Alright so if we are doing that then what!?!?!?
	* What does it mean to watch the watchers?
* 2023-02-02T01:24:28-05:00
	* Oh crap it is pretty late and I have full energy
	* Alright how are we doing this?
	* We need to get to work
	* We found out on the walk that we want the protocol to facilitate conversation
	* But I don't know what kind of conversations I want it to have
	* Alright so tell me a story
	* What kind of story!?!?
	* So Randy logs in, sees an empty question log!?!?!?
	* Ya, then goes to your_persona, and asks a bunch of questions and statements.
	* What questions does he ask?
	* We already did this
	* Ya we did
	* We need to work on the transactions and query_memes API's
	* How so
	* Alright so I go to Randy's page and he has a question asked
	* YES AND
	* Stacy has to pay to see the answer to his questions
	* Yes
	* Okay and that appears in her Quest(ion) Log and when she goes to Randy's Persona page again
	* So we need to be able to do a bunch of different types of queries
	* Alright I want to be posting on there rather than here
	* You want to just dump random ideas 
	* No like the random stuff I have in the Quest(ion) Engine page
	* Paul why don't you go talk to actual people
	* I don't know what I want from them
	* I feel constrained by the nature of social etiquette 
	* What role to each of my relationships have in my life?
	* What quests are you working on Paul!?!?
	* Paul what do you want your quest log to look like?
	* Do I need people to mint my token before they can answer any of my questions
	* YES
	* Alright let's figure out what we need from the API's
	* Also how do you DM people?
	* No each person has a context that can be arranged chronologically or tagged
	* Alright time to do some real work
* 2023-02-02T00:49:58-05:00
	* Alright what's next?
	* It is my goal to use algorithms to enhance human agency while building infastructure cypherpunks would admire
	* How do I want to enhance the agency of others.
	* I want to enhance human agency in the spirit of the human potential movement. How smart can a human be? How capable can a human be? Enable people to make new scientific discoveries. Enable a new generation of polymaths. Enable people to make new friends. Give people the tools to fix their relationships. Give children the ability to call our for help. That sorta thing.
	* That might be vague but the general idea is to allow for the American dream. Anyone can become rich as long as they try their best.
	* Now who decided who get rich that's where the enhancing comes in.

## [2023-02-01](/2023-02-01)
* 2023-02-01T22:25:20-05:00
	* Alright we got a bunch of stories to write
	* Yes we do
	* How do you want to use Quest(ion) Engine Paul?
	* My primary purpose if to have conversations and provide quests for people and assign myself quests
	* Wait where is that story?
	* Ummmm let's write it
* 2023-02-01T21:17:46-05:00
	* We just spent a bunch of time within [Examples of Knowledge Management](/8d91554a-4bd1-4a29-a287-4979fa7d9da4)
	* My first quest it to find and index and map examples of knowledge management
	* Well does this deserve a user story
	* Yes Randy can be the guy
* 2023-02-01T20:27:06-05:00
	* Alright what do we do now
	* Well user stories
	* About what
	* No OBSERVATIONS
	* Watch how people use [dentropydaemon-wiki/Software/List/org-mode](/dentropydaemon-wiki/Software/List/org-mode) and [dentropydaemon-wiki/Software/List/Obsidian](/dentropydaemon-wiki/Software/List/Obsidian) and write about it what are they researching
	* Find your example knowledge gardens and integrate it into Quest(ion) Engine
	* Alright how do I want to organize this?
	* Here or Raindrop
	* Well can I link to a raindrop collection?
	* Shit I should learn how to do that
	* What questions do we want to ask
	* How do we want to oragnize this?
	* Well how about we judt just dump it in media
	* No this is websites
	* Meta Media
	* No
	*  This is definitely media
	* Alright
* 2023-02-01T19:21:27-05:00
	* I got some Omens and ads to sign up for IDEOU
	* Let's do it
	* Like right now?
	* Ya we should, what else are you going to do
	* Alright I will do it
* 2023-02-01T18:43:55-05:00
	* Alright what's next?
	* We need better user stories
	* We need meme graph's from here to transpose
	* Like what?
	* Hypnosis
	* Paul what do you want to lecture about
	* PROGRAMMING
	* How to code
	* We want Hello World as a meme
	* 
* 2023-02-01T15:57:03-05:00
	* Alright what does the frontend need?
	* Paul go on a walk
	* Ya I should do that
	* But I need to know what problem I am working on
	* You need to read your user stories and and add in API calls
	* Alright
	* So for the question_log page what API call do I make?
	* Hmmmmm
	* query_memes
	* Does that part of the API work
	* Alright go back and work on that
	* We need to map our how we would want to query memes
	* We need to figure out how to get the meme's from the user
	* We need to check the query_meme's API
	* Progress on this project is wayy too slow
	* That because it is not your top priority Paul
	* We need to have example meme graph's like tones of them that will sell this thing
	* What do you want to know about?
	* Shit that's a good question
* 2023-02-01T15:52:15-05:00
	* Alright where are we?
	* We have an app bar that switches pages
	* Alright what's next on the TODO
	* Oh shit we have that don't we
* 2023-02-01T06:49:26-05:00
	* Why is this so hard
	* Cause you are not doing it the correct way
	* What is the correct way?
	* Hmmmm good question
* 2023-02-01T06:25:38-05:00
	* Using navigate is not really going to work
	* Yes it will
	* Alright
	* It is just going to render navigate
	* No so the function updates a setState
	* Ahhhh smart
	* Wow we can actually use a switch statement
* 2023-02-01T06:23:02-05:00
	* Alright we got tabs!?!?!??
	* Now what?
	* Do we want to use react router or embed components!?!?!?
	* I thought the whole point of this was to use react router
	* So we gotta find the react router example and embed the paths in
	* Ya try that
	* But that is still embeded
	* So redirect and have this component at the top
* 2023-02-01T06:05:52-05:00
	* Alright what's next?
	* Well we gotta do the question_log screen
	* Do we have that in the API!?!?!?
	* What is supposed to appear in the question_log screen!?!?!
	* The real problem is which API endpoint do I pull from!?!?!?
	* Wouldn't it be better to send people to /your_persona so they can get a reflection of what they look like
	* No we want them looking at quesiton_log because our society rejects history
	* People do masturbate looking at themselves in the mirror
	* Alright so just add in filler for the user story
	* Sure

## [2023-01-30](/2023-01-30)
* 2023-01-30T23:58:32-05:00
	* Alright the user flow should be if you go to a new tab you need to type your pseudonym in again and save that to the context
	* We can do this with a modal
	* How about if the user does not have the context with pseudonym and public_key we delete the cookie
	* Sure why not
	* So if we find a cookie without setting it, we delete it and request a new one?
	* Why is this so dam hard
* 2023-01-30T23:34:48-05:00
	* Change of plans let's do this the proton mail way
	* Can you do custom cookies in teach tab?
	* Nope
	* So if we are going to do sessions rather than cookies we need to update the entire API
	* Well it is not that hard
	* The only way we can do cookies is if we store the pseudonym and public_key
	* But those always change
	* Alright how hard would this be to change
	* Oh fuck we would have to change ALL THE TESTS
	* Or we can just store the pseudonym and public_key
	* Let's store the pseudonym and public_key
* 2023-01-30T23:32:40-05:00
	* New problem, how do we manage the pseudonym and public key?
	* So if the user goes to a new tab
* 2023-01-30T23:05:47-05:00
	* We got some serious cookie problems
	* Paul you should have scoped these out like you did the database
	* I did not know it would be so complex
	* Alright so what's the problem?
	* So we have a user story
	* go to /wield_person
		* check_cookie()
			* logged in 
				* Redirect
			* Invalid cookie
				* Request new cookie
		* Login
			* Redirect
			* Show pop up error
	* Alright what is our problem!?!?!?
	* The context does not save
	* Why is that?
	* No clue let me look at the code
	* 
* 2023-01-30T20:12:20-05:00
	* Alright we can not update the context cause we do a async stuff
	* Or do we store the metamask stuff inside context
	* Ya that would make sense
* 2023-01-30T18:25:30-05:00
	* Alright so how do we want this auth to work!?!?!?
	* 
* 2023-01-30T18:07:47-05:00
	* Let's do auth from scrach
	* Alright then create your context
* 2023-01-30T16:41:58-05:00
	* Huston we have a problem
	* We have /wield_persona SCREEN and /wield_persona API call
	* Shit I did not think about that
	* What are we going to do about this
	* The screen is important
	* Can we throw everything into /api then we just have a single route for everything
	* Ehhhhhh yes that would be the correct way to do things I guess
	* But it can be /api/wield_persona
	* Alright I should be able to do that
* 2023-01-30T16:32:48-05:00
	* Alright what's next?
	* Test everything dummy
	* Alright we were at signing but had not sent it to the frontend
	* We are supposed to now send the request, get the response, and go to a new page
	* How do we go to a new page
* 2023-01-30T15:12:54-05:00
	* Alright where are we now?
	* Well let's see what's next
	* We need to finish /wield_persona
	* Then what comes
	* Question_log
	* Yes
	* Then what comes after that?
	* Where does the user go to see their personal questions
	* Then they have /your_persona
	* 
* 2023-01-30T03:10:04-05:00
	* Alright where are we?
	* Well
	* Let's see
	* We got the cookie management working, that should probably be modularized
	* Next we should finish the signing in logic then we should do the question_log path
	* Alright that works
* 2023-01-30T01:42:47-05:00
	* Alright how do we want to do this!?!?!?!?
	* So the wield_persona has a modal dependent on weather or not metamask is working
	* Yes sooooo
	* Well we need our little modals dependent on if metamask is detected
	* Cool so do the useEffect thing there
	* Alright do it
* 2023-01-30T00:45:29-05:00
	* How do we want do this?
	* Do what?
	* Ummmmm
	* I want to do metamask login right now
	* Alright
	* So the home page does not need it
	* But wield persona and everything else does
	* Alright you are going to need a provider, the same thing as the auth provider in the react-router examples does
	* Except you will store the metamask state in there
	* So that means impliment the auth stuff first
	* YES
	* Thanks
* 2023-01-30T00:10:26-05:00
	* Alright do we want to use this auth stuff
	* Ehhh yes
	* Where are we storing the Auth state in the frontend?
	* Hmmmm good one IDK
	* Auth is all managed using its own provider
	* Do we want to have another provider!?!?!?
	* Sure makes the other context not be required unless it is needed
	* So are we copying auth and making it work for our app
	* We also have a different flow
	* We have the homepage
	* Then we have the /wield_persona
	* Alright so let's start by setting up the router
	* We can call it meme map?
	* No wait I like that's almost it
	* meme mapping
	* Yes

## [2023-01-28](/2023-01-28)
* 2023-01-30T00:01:39-05:00
	* Alright do we know what we want the final project to look like?
	* No
	* Alright that's a problem
	* Now what are you going to do about it
	* WAIT WAIT WAIT
	* We already wrote the paths we want
	* / (Homepage, just like protonmail)
	* /wield_persona
	* /persona/:persona_ID
	* /my_persona
	* /question_log
	* /context_feed
	* /discovery
	* Wait where do people do custom queries
	* Hmm how about quest query
	* No I don't like that name
	* What name do you like?
	* QQ Quest Query
	* DIY Context
	* How about just Contextualize
	* Hmmmm that works but doesn't describe things nicely
	* We can name it later
* 2023-01-29T23:57:15-05:00
	* Alright let's make a decision
	* Do we rewrite the code with vite and react router
	* YES of course
	* then stop doing stupid shit
	* Alright we got the code, now do we copy a react router example or do it from scratch?
	* Well we should do it form scratch so we know what we are doing
	* Alright
* 2023-01-29T23:11:06-05:00
	* Alright so we need to learn react-router
	* So for the user story we need to do what exactly?
	* We need different paths right
	* So we can have like
	* /app
	* / (Home)
	* Then when we look for specific users we can have
	* /persona
	* /my_persona
	* /wield_persona
	* Ya
	* Alright let's do it
	* Dude you need a better plan
	* Ya
	* Or do we want to do
	* /context_feed
	* /discovery
	* /view_persona
	* /wield_persona
	* /your_persona
	* Ya dude that makes way more sense
	* Alright are we doing it?
* 2023-01-29T20:46:00-05:00
	* Ahhh shit we should probably learn react router
	* Ya it would probably simplify things
	* How would we know what page the user is on without react_router
	* Can't bookmark something without react router
	* Alright let's try and use react router
* 2023-01-29T20:43:06-05:00
	* Alright we actually have a home page here
	* Yes we do
	* What does that mean?
	* Well this page select and stuff needs to go somewhere else
	* Ya so this can be in a LoggedIn component
* 2023-01-28T16:43:20-05:00
	* Alright what pages do we have?
	* We gotta rename that from screens to pages
	* Well my keybase binding did not use react router, https://github.com/dentropy/ddaemon-monorepo/blob/main/app-web/frontend/src/App.js
	* It was just a single page web app
	* Well let's checkout the testing branch and see what we can do
	* Wait which way is simpler, just do what I had with the keybase bindinding or try this other way
	* Alright we can skip react router
	* Okay but what was our hack last time
* 2023-01-28T16:35:12-05:00
	* Done that was easy
	* Alright how do we want to do this?
	* Well we can just pull in a bunch of UI elements and we should be good
	* No we start with the USER story
	* Wait does react require a UI path?
	* Ummmm that's a good question
	* React router time
	* Alright what pages do we have
* 2023-01-28T16:29:26-05:00
	* Alright let's make a plan for the frontend
	* Alright first we need the proxy stuff
	* Ummm how do we do that
	* Ehhhhh
* 2023-01-28T16:11:39-05:00
	* Food achieved
	* Alright what next?
	* Well I think we can do the react frontend
	* Hmmm we can't do the cool bits
	* But we will find the mistakes
	* Do you wana do the queries for revealed transactions and stuff
	* YES but that is well scoped
	* I need these problems being solved in the background
	* Alright create-react-app here we come
	* MaterialUI Style
* 2023-01-28T15:49:33-05:00
	* We should get some more food
	* YES
	* But we also need a plan for what to do next
* 2023-01-28T15:18:45-05:00
	* So do we want to have a persona object 
* 2023-01-28T15:09:23-05:00
	* Alright let's organize what queries we are doing
	* How so?
	* Ummmmm
	* How does this persona query work
	* Well we check for pseudonym and public key
	* Get the UUID of the user
	* After that we get what was it?
	* Okay so when we query a person
	* We get all their what codes do we want?
	* Well PUBLIC of course
	* We are going to need a wya to query things correctly
	* Okay so ONLY_OP means that only the ROOT_MEME persona can see it
	* ONLY_THIS_MEME means that only the person you are responding to can see it
	* ONLY_THIS_THREAD means that every meme in the thread can be seen
	* Alright so this is a lot of queries that need to be done, espically with the threads
	* Well we reference the root meme so we can do a recusive query no problem
	* Paul first things first
	* What's first?
	* Ummm we lookup the persona
	* Alright
* 2023-01-28T14:50:24-05:00
	* Do we want the different query_types to be what
	* CAPS or not?
	* Well let's look at the Ethereum Queries
	* lower case
* 2023-01-28T14:29:27-05:00
	* Alright I fixed the order of the tests
	* Wonderful
	* Now do we want to do our own tests!?!?!?!
	* Like from scratch?
	* Ehhhhhh no
	* What would it look like if we do?
	* Cookie, Persona, Mint, Meme, Query
	* Fuck me then, fuck that
	* Why are we swearing
	* The same reason you went out for lunch, it feels good
	* Wonderful
	* Alright let's do this
* 2023-01-28T14:09:36-05:00
	* Alright what next?
	* We have different types of transactions the same way we have different types of meme
	* Wait we can remove get_balance and then just use get_memes
	* Calm down bro
	* Alright so we have get_memes
	* Then we can apply constraints for a couple SQL queries
	* So we can input the pseudonym and public key and get all their meme's even with additional constriants
	* Then we can query responses to a meme
	* Then we can query by type
	* Yes this works
	* So what does this API look like
	* JSON
		* query_type
			* persona
				* pseudonym
				* public_key
			* responses
			* root_thread
			* transactions
				* transaction_hash
			* balance
				* persona
					* public_key
					* pseudonym
			* revealed_memes
	* Ya that works
	* Alright then write it
	* Is this enough for the POC Frontend?!?!!??
	* I would add get_balance and stuff
	* Ya I think that would be enough wouldn't it?
	* Hmmmmmm is it?!?!?!?!
	* Hmmmm is it?
	* Well we can query and respond to meme's
	* We can't do the paid stuff tho
	* It is still POC
	* Ya enough for POC but the killer feature is paying to see other people's stuff
	* Ya that requires a schema upgrade
	* What kind of schema update
	* Alright so the story is
	* Paul write the dam user story
	* Alright let me get an outline
	* Wait we already wrote this
	* Randy has a SECOND QUESTION with a STATEMENT that requires payment
	* Good that's the story
	* So how does Stacy pay for it?
	* Well her TRANSACTION code would be what exactly
	* Well we did not code that in
	* Well wana do that now maybe possibly that would be great
	* Alright what are we calling
	* REVEAL_MEME
	* that works
	* I appreciate MEME_EDGE_PAYMENT as a transaction type because MEME_PAYMENT cay pay for either kind
	* So when we query the memes of a persona how do we get the revealed meme's
	* Why we need to look at the transactions done to reveal memes
	* That makes sense
	* But does that mean that we also update API
	* Ya let's do that
	* So we can just query revealed_memes how's that
	* Ya then we can list all of them
	* And then just do recursive API calls till victory
	* Then when we ask for help with GraphQL we will have example code we want to get optimized and stuff
	* Wonderful
	* So what are we doing first
	* Well where does query_meme's go? Helper or Transactions
	* Definately helper
	* Would it be better for all these to be in their own file?
	* Nah only do that if the file get's like 150-300 lines
	* That makes sense let's see if we get there
	* Alright what's next then?
	* So we are going to add the endpoint or file query_meme's and export it into index.js
	* Cool
	* Then we search for all the different keys and return an error
	* Good
	* Then we use a SWITCH STATEMENT
	* Ehhh yes
	* No, switch statements don't do brackets or if they do it is different
	* Alright so a bunch of if else statements looking for their key
	* Yes
	* Then we return errors
	* Yes
	* Then we plan them out
	* Okay first
	* Let's make sure our tests are running in order
* 2023-01-28T14:07:25-05:00
	* Back already 
	* What do we want in there
	* Hmm we want to query USERs
	* Ya that should be easy, so USER is an entity and then we return their memes
	* Alright I am thinking of this in terms of[dentropydaemon-wiki/Software/List/Ethereum/Ethereum Graphql](/dentropydaemon-wiki/Software/List/Ethereum/Ethereum Graphql)
	* We have different transaction types returned
	* Dude you already learned this go review the queries just look at [ENS Indexing](/28740a43-67c5-4930-8b5c-41c06e659c6a)
* 2023-01-28T14:01:49-05:00
	* Alright where are we?
	* So we need to code the MEME permissions, do we have /query_user or /query_memes
	* Definately query_meme's we want that to be graphql with AUTH
	* Good glad to see things are coming together
	* Alright what's next?
	* USER STORY
	* USER STORY
	* USER STORY
	* Where are we?
	* Umm Stacy needs to be able to query Randy
	* So are we adding the query_meme's endpoint now?
	* Hmmmm so for discovery can we just do query_memes
	* Ya technically depends what part of the graphql query we want
	* Okay that works
	* So /query_user and /discovery are going to become query_memes
	* YES
	* Chad meme yes
	* YES
	* What about request_persona
	* NO we request their meme's there is no persona without their memes
	* Sure so we combine them all?!?!?!?
	* Sure why the fuck not
	* So this needs to be designed somewhere
	* Well we do have an API folder here
	* Alright brb 
* 2023-01-28T12:20:43-05:00
	* It may be time for a walk
	* That was a good session
	* Alright my inuition is saying walk
	* So what do we do next?
	* Well read the USER STORY
	* Randy also add a question that requires payment
	* Shit we do not have RBAC yet
	* Wait for POC we do not need RBAC that is MVP
	* Oh good point
	* Okay we Add Randy's next question and then add another statement that requires payment
	* [Meme Permissions](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/User%20Stories/Meme%20Permissions.md) should have a payment feature
	* Ya these permissions need work
	* How about just add 
	* PAYMENT_REQUIRED
	* Wait we have different types of payments
	* We have take one of my tokens, or pay with your token
	* REQUIRE_PAYMENT_ROOT_OWNER
	* REQUIRE_PAYMENT_RESPONDER_AND_ROOT_OWNER
	* REQUIRE_PAYMENT_RESPONDER
	* REQUIRE_PAYMENT_PERSONAL
	* That works
	* Then we update the meme transaction
* 2023-01-28T12:15:48-05:00

 \* We have a problem
	* How do I know what meme was created
	* By the transaction hash dummy
	* Oh ya we designed this correctly
* 2023-01-28T12:04:18-05:00
	* Alright how do we want to respond to this meme?
	* Do we want meme's to be linked via edges to within the database
	* Meme responses should reference the root MEME
	* Alright add that to the database?
	* Sure why not
	* Alright done
	* No
	* Yes so you can respond to memes with meme
	* Well doesn't that go against graph theory
	* That's just an unlabeled edge
	* Alright we can insert MEMES that's good
	* PAUL follow the fucking user story
	* Wait don'e we want to have answes?
	* No people find their own answers and label them that way via edges
	* So the response would be a statement
* 2023-01-28T11:22:28-05:00
	* I was wrong we do not want to do the data validation in the normal transaction function requires an additional input not PURE UNIX Philosphy type of function
	* Now the problem is do we want the MEME to have a title and a text
	* No we probably want it to have a body, let's look to keybase for this one
* 2023-01-28T11:15:43-05:00
	* Let's check for internal_data within the general transaction validation function
* 2023-01-28T10:58:21-05:00
	* So BURN also needs to have the same constraint doesn't it
	* YES
* 2023-01-28T10:50:44-05:00
	* So we can't just send tokens to oneself, where do we send them to?
	* Ethers Zero Address
	* What is that  pseudonym
	* ZERO
	* So Zero as a name is taken by default
	* YES
* 2023-01-28T10:46:45-05:00
	* Do we want to fix the API and have transaction_data and data?
	* YES
	* That's a lot to change
	* No internal_data
	* Alright we good
* 2023-01-28T10:40:12-05:00
	* Here is a decision, NO TAGS ON MEME's we use EDGES
	* 
* 2023-01-28T10:31:20-05:00
	* Alright do we want the description to be an answer to a specific question
	* Why not, it can be like everyone's first friend in Myspace, it also gives me more volume on the network
	* Lol why not
	* Alright so we need to post a question and an answer
	* How do we want to do tags?
	* Also what about the codes
* 2023-01-28T10:14:56-05:00
	* Alright what is the flow we want
	* We want both users to mint their own tokens
	* Then we need one to use the faucet, or do we want one to post a Question
	* We want both
	* We want to copy what is in the user story as a test
	* Alright so what are we doing?
	* Randy has to use one of his own tokens to post a question and answer
	* Cool we can do this
* 2023-01-28T09:49:56-05:00
	* Alright let's think through this meme
	* What about it
	* Well where do we start?
	* We need to verify the data
	* Yes what else
	* We need to put it in the MEME's table
	* Let's look at that
	* Oh wait I think the MEME table assumes the MEME is signed separately
	* Oh fuck that bro NOPE
	* Alright let's just get the tests written
	* Remember [dentropydaemon-wiki/Software/List/Tiddly Wiki](/dentropydaemon-wiki/Software/List/Tiddly Wiki)
	* ALright we got it
	* Write the test now
* 2023-01-28T09:32:44-05:00
	* Alright what do we need to get done today?
	* Meme, Meme Edge
	* query_persona
	* How do we reveal stuff via ACL's and stuff
	* Oh ya we did not figure that one out did we?
	* Alright what comes first
	* First things first
	* MEME and EDGE transaction codes
	* Yes we can add them in and add boiler plate
	* Then we can take in the data with the correct keys
	* We are going to need an ACL_LIST_T ACL_USER_IDS_T and REVEALED_POSTS  stuff
	* Alright so the plan is 
	* MEME and EDGE transactions
	* Write the tests
	* So what are the token requirements for MEME and EDGE transactions
	* This is why we were working on USER Stories last night
	* Alright so you need to pay to reveal someone's question
	* Yes of course
	* But what do you pay with to respond
	* THEIR TOKEN
	* Alright that's simple enough
	* But why can't I also pay with my token
	* You want to do an ALSO, to complex, this is POC not even MVP
	* Alright so YOU NEED someone's token to respond to them
	* Ya that's simple enough
	* Ya and we already got the faucet figured out
	* I am excited to get [Jesse](/Jesse) involved in this

## [2023-01-27](/2023-01-27)

* 2023-01-27T17:37:07-05:00
	* Alright let's reread my user stories
	* While rereading the user stories I see my code has diverged
	* Do we want people to use other people's faucet's before they min their own token?
	* Hmmmm that's a good question
	* We can have a modal that pops up when appropriate
	* Ya we have sorta been assuming that
	* So what does this Modal do?
	* Okay what is the User flow?
	* So the user goes to what exactly
	* [What conversations do I want to have?](/What conversations do I want to have?)
	* Alright 
	* What is it
	* That's a question I should genuinely answer
	* My creative mind is not working right now
	* Then churn out more tests
	* What conversation do I want to have with my life?
	* What am I waiting for?
	* I want an system to reverse engineering the human soul?
	* That's stupid
	* How are people supposed to interact with one another
	* By asking questions, [What constitutes a persona?](/What constitutes a persona?)
	* What knowledge do I want to represent within the question engine
	* I want to get a list of people's values and interests then go about coming up with quests we can work on
	* You know if I did a cool investigation into "[What are Values?](/What are Values?)" in tiddlywiki I could have a set of data to parse and input
	* Well the problem is [How do I want to assert my will on the universe?](/How do I want to assert my will on the universe?)
	* Alright let's go work on this for a bit
* 2023-01-27T17:21:30-05:00
	* Alright what are we going to try and do next?
	* Hmmmm
	* It's MEME time
	* We need the structure from Tiddlywiki
* 2023-01-27T15:35:38-05:00
	* We are doing the meme's now right
	* Ya we need some new user stories, cause we need to map out these permissions and stuff
	* Wouldn't it be funny to encode all the name of files in Hex then store them in the file system
	* Unicode to Hex, yes that would be funny
	* What stories are we truing to write
	* What stories do we want to write
	* I should go on a walk and think about this
	* Ya that would be a good idea
* 2023-01-27T02:49:13-05:00
	* Alright we got the facuet working
	* We still need to write a bunch more tests
	* We can do that another time this POC you know
	* What is the next transaction type?
	* Meme's I guess
	* Where is my old Tillywiki
	* I doubt I can find one
	* Looking at a test TIddlywiki I see the innovation is mostly in the UX, I already got most the data
	* The tags and links are edges
	* No tags are meme's to they have edges to them and away from them
	* But I might want to use a tag while I move through something
	* So I want to say that this meme relates to another meme with this meme
	* Let's look at the schema
	* We already got that this figured out
	* Our meme Edges have a tag
	* So the edge can flow through something
	* And the edges have a direction
	* What was the important video youtube recomended me a long time ago
	* Can't find it
	* So are we doing MEME and MEME edges tonight
	* Well we can probably get away with MEME's IDK about MEME edges
	* Wait are we at MVP if we get the MEME stuff done?
	* Ummmm Ya I think so actually
	* NONONONONO
	* We are done inserting data, we still have /discovery and /request_persona and /query_user
	* Dam Alright this is doable very doable
	* Imagine auto generating 
* 2023-01-27T01:48:05-05:00
	* Alright what do we need to do for Use Faucet
	* I should name the bear on my deak
	* No it is a moose
	* Elliot
	* No that name is stained 
	* Fred
	* Fred the Moose
	* No something with a M
	* Mark the Moose
	* That works
	* Mark you are going to help me troubleshoot this project
	* Also if anyone reads this, you can find Mark the Moose on my twitter
	* Alright Mark
	* I need to verify the faucet can be used, if true, perform a transaction and update balances
	* That seems doable
* 2023-01-27T01:45:39-05:00
	* Alright we have the tokens and their faucet
	* Good
	* Now actually write a script to use the faucet
	* What is the code 
	* USE_FAUCET duh
	* Alright
* 2023-01-27T01:29:18-05:00
	* Alright what's next
	* We develop the Faucet
	* Then we can do the Meme's friday
	* Then there is the PERSONA and DISCOVERY Stuff
	* Then we can do the Query Engine while developing the UI
	* Alright what are we doing
	* We are running out of time bro
	* Alright break down the task
	* What about it?
	* Alright Facuet is the biggest feature we are implimenting so far
	* Dude you also have to think about the meme JSON structure
	* I should do a Tiddlywiki Export
	* Ya that would be a good idea
	* Then what?
	* No what now
	* How do you need to update the MINT function
	* We need to place the token in the TOKENS_T table
	* Ya that would be a good thing to do
	* We also have a cool_down and stuff
	* Yup
	* Alright what do we do after we have the mintig function done
	* Well we can simply just create a USE_FAUCET transaction and be done with it
	* Turning off and modifying the FAUCET can be done another time
	* Well we may want to turn it off, but that will be easy
	* Then we also need a transaction to turn it back on
	* That is two transactions
	* Can the POC work without modifying the faucet
	* YES
	* Then skip them and add it to the back log
	* Alright this is doable now


## [2023-01-26](/2023-01-26)

* 2023-01-26T21:46:52-05:00
	* Alright we have a new table
	* Good
	* What now then
	* We need to update the MINT function
	* Yes we do
	* Do we search for the token in the TOKENS_T now
	* Ya we probably shout
	* I can feel my brain starting to run low
	* I don't matter
	* You can make yourself matter
	* Why do you even want to matter
	* What would mattering even look like?
	* Alright what's the correct move
	* Fix mint function
	* Do you have the energy for that 
	* No 
	* Then commit and go on a walk
* 2023-01-26T21:41:21-05:00
	* Alright now what?
	* We want to be able to freeze tokens entirely
	* Add that to the backlog dummy
	* Wait wait wait
	* Is this the correct way to do things!?!?!?
	* It's a big feature
	* This can be added in later, it makes things much more complicated
	* Alright
	* We already have TOKEN status
	* Ehhhh ya schema mistake
	* And the faucet should be stored there anyways
	* Alright we have a TOKENS_T table
* 2023-01-26T21:32:21-05:00
	* Alright what's next
	* Alright we got the check_balance
	* It seems to have taken half an hour
	* Nice
	* What's next?
	* We can go ahead and fix all the tests
	* Ya no that's monatonas
	* Alright what you going to do then
	* Alright what are we doing next?
	* Hmmmmmmmmm
	* We need the faucet working and stuff
	* Yes we do need the faucet
	* What about the faucet
	* Hmmmmmmmmmm
	* What are the requirements
	* Well we say if it is on or not
	* Yes
	* And give it an amount
	* Yes
	* Then give it a cool down period
	* So we have a single FAUCET transaction
	* Yup
	* Then we store it's stats within the user's own token balance
	* Ya it's their token after all
	* Ya this makes sense let me check the database
	* Alright we have TOKEN_STATUS which is a string
	* We should have FAUCET_VALUE
	* Alright add it
	* THen TOKEN_STATUS can be if it is on and stuff
	* Also what are we doing for permissions
	* Oh ya those we fucked up on those didn't we
	* Well we need ACL or something like that
	* Fuck I wonder if this could all be done with LINUX permissions
	* You know what that's sorta what I am reinventing here arn't I
	* Reinventing what
	* LDAP, LINUX permissions and file system
	* Call it a MEME file system
	* What is the difference between that and a graph database
	* It is a specific implimentation of graph database
	* Write it down it is something of value
	* Alright so our FAUCET_VALUE
	* What do we call a Faucet flow
	* Lol sure
	* FAUCET_FLOW in ms
	* Sure let's add them in 
* 2023-01-26T21:05:52-05:00
	* Well we should do something
	* Like what?
	* We need to define the transactions API
	* How about just a check_balance
	* Take is two pseudonyms and two public keys and say the balance
	* Sure why the fuck not
	* First let's pull out these big functions
* 2023-01-26T20:58:54-05:00
	* Alright are we doing the balance API now?
	* Ya that should be easy then we can get it done
	* What is after that?
	* Hmmmmmm
	* Faucet stuff
	* What after faucet?
	* Faucet is too big if you finish that tonight you are good
	* Then you are working on memes and stuff
	* Alright we can do this
	* 
* 2023-01-26T20:42:10-05:00
	* Alright what should the steps for REMOVE look like?
	* Check if issuer matches from
	* Sure
* 2023-01-26T20:32:59-05:00
	* Alright what's next?
	* We spend an hour then go to Gym
	* What's next?
	* We just have to do remove
	* Then we should write the balance API
	* Should we write the balance API through?
	* Whatever don't I am not your boss
	* Yes you are
	* Do we want people knowing this is how I have conversations with mysefl?
	* Sure why the fuck not
	* Dude there are so many reasons
	* Alright what's next?
	* REMOVE
	* fuck it we go till we tired, forgot to pay for gym membership
	* Alright what's next?
	* You know REMOVE
	* Yes but "BREAK DOWN THE PROBLEM"
	* Alright how do I do that?
	* Hmmmm good one, how about
	* Write the test first
	* Ya we are going to have to write the balances API after this
	* That should take like 10 min, we hook strait up to table
	* NOW FINISH REMOVE transaction
	* Alright do we need to form, and token
	* We do not need token
	* We should verify this shit
* 2023-01-26T20:23:51-05:00
	* Alright Paul, every pair of token owner with token holder needs to have a separate row in the database
	* Crap that makes sense
* 2023-01-26T19:51:19-05:00
	* Alright we don't really need the fields mattching
	* No but we need to
		* Check user has balance
		* Check to user exists 
		* Has enough tokens
	* Wait in the MINT function do we check if the user exists or not?
		* No we already did that that's why the UUID is fed into the function
		* Wow maybe I can trust my past self sometimes
* 2023-01-26T19:41:03-05:00
	* Wait does the transfer require what exactly?
	* Does the user have to have issued their own token?
	* Well there should be a registration transaction
	* We did not impliment it this way
	* Shit, there should be a regestration transaction
	* You do not create your persona in a void you anounce it to the world
	* No you have to mint, you have to say you have worth before you are allowed to speak
	* Whahahah The symbolisim
* 2023-01-26T19:15:19-05:00
	* What's next then?
	* Why we ummm
	* TRSANSACTION transaction
	* Remove Transaction
	* Faucet stuff
	* Then Gym
	* So how do we do this?
	* Ummmmm
	* How about we write the test
	* What is our transaction code
	* TRANSFER
	* Wait we need to register other users and stuff
	* Ya let's write another test
	* Alright so we mint, then transfer to the other user
* 2023-01-26T17:25:12-05:00
	* Alright what's next?
	* Hmmm we have the burn transaction working
	* Good what's next
	* The transaction transaction
	* Then what
	* Then remove
	* Then what
	* Faucet stuff
	* Then we get to the actual memes
	* THen we need an REST endpoint to query the transactions
	* That should be easy
	* What's after that
	* Request persona, Discovery, and Query User
	* So how hard would it be to add GOOGLE auth to something like this!?!?!?!?
	* Not hard we have the UUID user talbe for a reason, also I can FINALLY hire someone to teach me this stuff
* 2023-01-26T16:31:59-05:00
	* Alright what's next?
	* Why ummmmm
	* We have those other functions to implimen
	* What were they
	* TRANSFER
	* REMOVE
	* BURN
	* FACUET's
	* Okay for the FAUCET's
	* Can people endlessly call form it
	* No there is a cool down
	* Is that in the database
	* We can call that, the faucet funcitonality needs to manluable
	* Alright let's make all the JS files
	* Done
	* Now copy the contents of the mintjs and rename them all, then go through adding comments where things need to be changed
	* So the user can burn any tokens they want
	* So what validation do I need to do?
	* There is no to_public_key
	* Or do we fill that one in with a zero or something?
	* Does EthersJS have a zero token or something
	* Yes, [https://docs.ethers.org/v5/api/utils/constants/](/https://docs.ethers.org/v5/api/utils/constants/)
	* Do we want to import EthersJS just to pull the Zero
	* Hmmmmm yes, produces better errors
	* What about the pseudonym
	* How about we just set them to null
	* Ok good
* 2023-01-26T01:57:14-05:00
	* Alright Paul how fast can you do this?
	* I can do the next couple transactions tomorrow at some point
	* What about the meme's
	* I have no idea what I want to store in them
	* You need more use cases
	* Alright so what are we doing?
	* So the meme's, we just need to verify the data and stuff and dump it reguardless
	* What would the JSON look like?
	* Wait where did we write about this?
	* DO we even need to validate
	* YES this is a fake blockchain app
	* We are getting confused
	* Alright what do we want the meme's to look like
	* Wait we have the schema
	* [List of Database Codes](/List of Database Codes)
	* There you go bro have fun
	* 
* 2023-01-26T01:48:51-05:00
	* That was harder than expected, Paul are you going to relax now or keep grinding
	* I need to relax
	* But I want to have the next problem in my head
	* So we wana do transfter
	* TRANSFER
		* Query balence, double where
		* Is user blacklisted?
		* Does user have enough?
		* Remove and add
	* REMOVE
		* Check if owner of token ISSUED
		* Substract accoringly
	* Burn
		* Check balence of token, double where
		* Do math to make sure still above zero
		* BURN accordingly
	* Faucet on / off,
		* How do we know the faucet is on or off, is that in the schema?
		* Yes it is TOKEN_STATUS, we were asking what it was used for, we already thought about this
		* So check if user, change state accordingly
		* Do we just wana do FACUET_STATE and then read it
		* No the code should do it, less moving parts
	* Wait BURN and REMOVE are the same thing
	* Well someone can burn tokens they own, other users can burn tokens others own that they issued
	* 
* 2023-01-26T01:41:23-05:00
	* So I just got the first transactions done, what next
	* Well what other transactions do we have to do?
	* Memes
	* Meme Edges
	* Transfer
	* Remove
	* Burn
	* On Faucet
	* Off Faucet
	* Wait do the users fill the faucet
	* You have to mint for yourself then fill the faucet
	* Ya that sounds about right
	* No turn the faucet on, then see if people spam it, if they do, block them and remove their tokens
	* So we need faucet on
	* Oh we need a transaction to request from someone's faucet
	* Alright how hard can these things be? They are just a series of SQL statements right?
	* Ya well technically
	* We also need a API to query balances and blocked status
* 2023-01-26T00:26:47-05:00
	* Alright what's next
	* We have to input all the different types of transaction
	* That's a LOT of logic
	* This is the type of job you want to be doing, now show you can do it
	* We need to pull out the transaction logic and put them in a folder or something like that
	* Ya each transaction should have it's own type
	* Alright we doing all the transactions
	* Sure why not!?!?!?!?
	* So we have EP, MP, T, R, B,ON, OFF, BU, UB, and BUDT
	* Fuck that's a lot
	* Get to work
	* This code has to be pulled out
	* So does this all go in a class
	* Repeat what you did for the DB
	* We have a function
	* Alright then do a function
## [2023-01-25](/2023-01-25)


* 2023-01-25T23:53:53-05:00
	* Alright what's next?
	* Fix the status codes
	* They work
	* They are ugly
	* Alright what do you want the status codes returned to be
	* response_type
	* response_code
	* description
	* Alright what is the opposite of error?
	* success
	* Alright I can go add those in everywhere amd log the ones I find
* 2023-01-25T23:48:00-05:00
	* Alright what's next?
	* We had an error last I checked
	* What was TOKEN_STATUS_T_HASH for
	* Alright what's the next problem?
	* We need to fix the error codes and stuff, we did not plan those out we are just reacting
	* Ya you should have response_code and response_type
	* Yayayayaya we can fix that
	* You should do that now
	* Why now
	* Just do it trust me
* 2023-01-25T16:53:45-05:00
	* So how do we want to do the root transaction, mintable or not!?!?!?
	* No we can have balances of other people's transactions, we need to check
	* 
* 2023-01-25T16:38:58-05:00
	* We need code to verify transaction
	* We need an API to fetch transactions
	* Ah that is what we are missing
	* You know at a certain point it it easier to just use an actual ERC20 minting script and stuff!?!?!?
	* Nope out of scope, would be pretty strait forward to add, also can't attach metadata to ERC20!?!?!?!?!
	* OR CAN WE
	* Not easily googleable, through would likely be pretty easy to add
	* And if you are doing that you can do the Smart Contract for NFT minting as well
	* And if You got the NFT minting you need a NFT shop thing cause we on testnet bro
	* Ya bro don't do that
	* Alright we need to verify if the signature chain is there
	* So we check if this user has done a signature, return transaction as TRUE if valid or FALSE if invalid
	* Sounds easy
	* What do we need to check?
		* Does this user have previous transactions
		* Does this transaction come after the old transaction in terms of time
		* Does this transaction reference the previous transaction hash
	* Is this the right thing to do
	* Yes
	* Then we git commit
	* Ah shit we need a nonce don't we 
	* Yup
	* Damit
	* Well that should be easy to verify
	* Nonce needs to be in database bro
	* OKOKOKOKOK
* 2023-01-25T16:07:32-05:00
	* We need to check if the user exists first
* 2023-01-25T15:35:46-05:00
	* Alright what's next?
	* Umm we have lots to do, we need to fix the MEME codes and stuff
	* We need to add in all the different types of transactions
	* We need to do the logic for the transactions
	* So what are we doing with mint
	* We read M then what 
	* Verify the correct fields match
	* Then what?
	* Mint, aka change balence
	* Can sequalize add in a single update rather than anythign else
	* Yes sequalize has it [https://sequelize.org/docs/v6/core-concepts/model-querying-basics/](/https://sequelize.org/docs/v6/core-concepts/model-querying-basics/)
	* Alright so you doing this or going to do you actual job that pays you money
	* Also what if user does not have the token
	* Well we need to check that don'e we
* 2023-01-25T12:54:19-05:00
	* Wait I might be retarded
	* We can extract everything from send_transaction
	* If meme's and meme edges are transactions
	* Well people need to be able to have their own throughs right, private comments and stuff
	* Hmmm yes technically but in POC
	* Ya we want people to be paying each other in their own made up stuff
	* So when would someone create a meme without a payment
	* Never, that's the point, people need to say how important everything they say is
	* This is a killer app, you get to say how important your speech is by minting and spending your own token
	* So submit_meme and submit_meme_edge are getting removed
	* Absofuckinglutely
	* Alright I am happy, this is getting simpler, we just removed two endpoints
	* And this endpoint does not need verification
	* Even better
	* What about a context feed API endpoint
	* What should it be called
	* 
* 2023-01-25T12:53:06-05:00
	* So perform transaction does not need the cookie logic, the transaction is either correct or not
	* Yup
	* Cool
* 2023-01-25T12:27:28-05:00
	* Alright we have the test written
	* What now?
	* Well we need to process this code somehow
	* Well the request
	* Yes what about the request
	* Hmmmmmm
	* We need to do a series of SQL queries
	* We need a switch statement based on transaction code
	* We need to parse the JSON for the data then see if it matches the right codes and stuff
	* Alright so the logic
		* Parse JSON
		* Switch statement on transaction code
			* Match transaction_code
				* Check if correct key's are there
				* Verify issuer, from, and to are valid for this specific type of transaction
				* Verify data and hash (optional)
				* Lookup each user in the database and match with USER_ID
				* Verify Balances (depends on transaction type)
				* If valid add transaction to database
				* Change balances accordingly
	* Wow this takes a lot longer than I expected, I can't write a full API endpoint in an hour
	* Well maybe we can we are just trying to match one transaction type
* 2023-01-25T12:12:43-05:00
	* keys
		* data (optional)
		* transaction_data_hash
		* transaction_data
			* token_issuer_id_pseudonym
			* token_issuer_id_public_key
			* from_user_id_pseudonym
			* from_user_id_public_key
			* to_user_id_pseudonym
			* to_user_id_public_key
			* value
			* transaction_code
			* data_hash
	* Should we do this another way
	* In what way?
* 2023-01-25T12:09:22-05:00
	* What data goes into a signed transaction?
	* Umm didn't we document this
	* No we can figuyre it out
* 2023-01-25T12:06:45-05:00
	* Alright so we writing the backend or the TEST first
	* Well we just want to do a simple transaction
	* Let's write the test
* 2023-01-25T11:56:04-05:00
	* Alright now what's the logic?
	* What do we check first
	* We can reuse the same code from before
	* Oh then we have to do the data thing
	* So we have the data, data hash, transaction data, transaction data hash, do we hash the hashes?
	* It would signal I know what a merkle proof is
	* Sure why the fuck now
	* So we sort them or just use the data hash first?
	* We will need a function to parse the data and financial stuff separately
	* Dam I was not thinking about this
	* What if we just reuse the data function then do some additional hash verification
	* That is simpler, less code to write
	* What is the pip saying
	* [PEP 20 – The Zen of Python | peps.python.org](https://peps.python.org/pep-0020/)
		* Simple is better than complex.
	* Well you know the data hash can ummm, be separate so you only have the transaction
	* Ya this is the best option
* 2023-01-25T11:46:35-05:00
	* Alright what are we working on today?
	* We can work an hour
	* Alright what are we doing in an hour
	* /perform_transaction
	* Ya sure why not
	* Tell me the story of perform_transaction
	* What info does the transaction need
		* token_pseudonym
		* token_public_key
		* from_pseudonym
		* from_public_key
		* to_pseudonym
		* to_public_key
		* transaction_code
		* transaction_value
		* internal_transaction_data (optional)
	* Do we want to rename it transaction_data rather than transaction contents
	* Well this is inside the transaction, it is the data that has to be signed
	* How about internal_transaction_data
	* Ya that works
	* So does internal_transaction_data store a transaction_code
	* YES
	* Alright let's do this
* 2023-01-25T00:52:48-05:00
	* Alright so we have the perform_transaction, submit_meme, and submit_meme_edge then request_persona, discovery, and query_user
	* All those could be done tomorrow if I really want them done
	* Except query user
* 2023-01-25T00:40:10-05:00
	* Alright what's next then
	* What does perform_transaction do?
	* Mints the token
	* Ya that's what needs to be done next
* 2023-01-25T00:28:59-05:00
	* Alright what's next?
	* Ummmm
	* Should we go on a walk?
	* Probably
	* Let's think about our priority for htis project
	* Well we have to add constraints and user dummy data
	* We need to come up with more example conversaitons
	* I can just ask simple questions
	* liek what
	* What is SQL
	* What is "The Internet"?
	* Who do you look up to as a role model?
	* What are you good at?
	* Alright what else?
	* What is set theory
	* So many questions
	* Wait we should not add users, we need to be able to add test data
	* What about adding test data
	* What is next in the user story?
	* submit_meme and submit_meme_edge I guess
	* Those should be easy to add
	* You need to decide on what JSON goes in
	* True dat
	* This APi should have been done tonight
	* We don't even know what transactions we want to do
## [2023-01-24](/2023-01-24)

* 2023-01-24T23:14:12-05:00
	* So if the public key is in the 
* 2023-01-24T22:59:04-05:00
	* What do we do about logging existing people in 
	* We need more tests that's what
* 2023-01-24T22:41:55-05:00
	* What about other types of changes, like name and public key?
	* Users can spend their own tokens
	* This is a separate registration transaction, like you know, get on the L2 to begin with
	* We are not doing anything with AUTH_T to delete stuff so leave it
	* Alright
* 2023-01-24T22:40:08-05:00
	* So these transactions are different, no value transfer, can't be null so no TRANSACTIONS_T
	* So do we store this all in the USER_T table
	* We do not get rid of signatures bro, that's not how the world works
	* Alright
* 2023-01-24T22:33:11-05:00
	* Wait we need to remember who these users are
	* So no THash we lost the fact we registerd them
	* What we really want is the token
	* So this in final application would be like taking a NFT and saying I use this NFT as my identity and attach a name to it. That would be on chain.
	* So it is a transaction and should go in the transaciton table, it has the data and everything
	* Alright I will throw it in the transaction table
	* And if the user already exists we don't
	* Alright that works
* 2023-01-24T22:29:14-05:00
	* So are these login messages transactions?
	* Well we want people to know they are registered
	* We register users when they mint their first token, so no this is just for auth
	* So does hits mean we do not have a T_HASH for USER_SET
	* No 
	* Remove it form the schema
	* YES
* 2023-01-24T22:24:34-05:00
	* Ya sure why not
	* Same as discord flow
* 2023-01-24T22:05:40-05:00
	* How is AUTH supposed to work
	* So you check the cookie
	* It returns false, "COOKIE_SET", or USER with PUBLIC_KEY
	* We do not want people with the same PERSONA's name
* 2023-01-24T21:46:42-05:00
	* Seems like we are missing something with the AUTH_T, we need the USER_ID, PSEUDONYM, and SIGNING_KEY all in there
	* YES
	* COMMIT
* 2023-01-24T21:36:42-05:00
	* Articulate yourself clearly
	* The input to check_cookie should be the token
	* The output should be EXPIRED, ALREADY_GOT_ONE, and USER_ID
	* Dude UNIX PHILOSPHY
	* What about it
	* ONE THING ONLY
	* Check cookie eixsts
	* If it does check if it has a user
	* Wait the check_cookie_exists does that
	* UNIX PHILOSOPHY
* 2023-01-24T21:33:48-05:00
	* Alright what's next?
	* Fix the cookies we do not know who is signed in
	* Alright
* 2023-01-24T21:20:18-05:00
	* Alright what's next
	* Why we need to actually save who signed in and stuff
	* And limit the number of instances signed in
	* What is the simplest way to do this?
	* If we recieve signature we sign in, that's it
	* We need to fix the cookie logic, cause we need to check for expired cookies
	* Ya let's fix that
* 2023-01-24T20:57:07-05:00
	* Explain to me what you are going to do?
	* We need to pull out the signing logic
* 2023-01-24T20:18:45-05:00
	* Alright where do we add the error codes!?!?!
	* Added to their API endpoint file
	* Alright what is next?
	* Producing signatures and verifying signatures
	* 
* 2023-01-24T20:08:52-05:00
	* We got the cookies working in the tests
	* We have the POST json coming through
	* It should be easy from here
	* Alright should we commit?
	* YES
	* Wait we already decided what we want to do
	* Verify Hash and Verify Signatures
	* After we get those done things should be simple
	* And the database update
	* That should be easy we just adding a bunch of text columns
	* So we doing the hash verification now!?!?!
	* YES
	* Alright we need error codes and stuff
	* MISSING_KEYS
	* INCORRECT_HASH_OF_DATA
	* INCORRECT_SIGNATURE_OF_DATA_HASH
	* INCORRECT_SIGNATURE
	* sure why not
* 2023-01-24T19:21:35-05:00
	* Alright what are we working on now?
* 2023-01-24T18:35:37-05:00
	* I guess we have to write proper tests now
	* Yes
	* So do our tests run on their own server or do we run it
	* We run it, at least for now
* 2023-01-24T18:33:50-05:00
	* Should I call it data or JSON
	* JSON would be confusing
	* Alright
* 2023-01-24T18:23:47-05:00
	* Alright we got it the cookie problem is fixed
	* Wow I am horrible at API design sometimes
	* YES YOU ARE
	* Alright what is next?
	* HASH JSON and stuff
* 2023-01-24T18:08:58-05:00
	* Paul you still have not told me what you are doing?
	* Okay let's think through the backend
	* We need to take the input then verify the hash, then verify the signature
	* YES that's it
	* Then input into database
	* For frontend we need to take JSON, stringify
* 2023-01-24T18:04:33-05:00
	* Do we write the test or the API endpoint first
	* We write or run code that can hash
	* Then make sure it can hash the same way
* 2023-01-24T17:59:49-05:00
	* Found the code from the sfeed project
	* What are we looking for?
	* The question is, how do we hash the same JSON consistently
* 2023-01-24T17:56:14-05:00
	* Can't find it
	* Ok what now
	* We need to write a hasher and signer
	* Alright install ethers then
* 2023-01-24T17:46:54-05:00
	* Alright what's next?
	* Ummmmmm
	* It's daemon time buddy
	* How so?
	* Close your eyes
	* API Time
	* We have a TODO list
	* Oh we need the laptop
* 2023-01-24T14:42:47-05:00
	* Alright we are back, this time with working cookies
	* Alright you git commiting
	* No
	* You should
	* Let's decide on what we are doing first
	* What are you deciding on?
	* We need to get ethersjs and stuff in here and working
	* In what way?
	* We need to find our old signature code where did we put that
	* It is on my laptop, IDK if we saved it anywhere, I don't think we did
	* Alright commit and grab your laptop
	* Wait let's plan this out better
	* In what way?
	* You need a signature verification function
	* Add that to the todo list
	* You also need a hash verification function
	* Can't we easily do that
	* It should sort the JSON and stuff
	* Well the JSON is stored as a string
	* Well this is an important design decision
	* JSON should be stored as a string AS WELL AS data
	* Shit, does this require a database migration / upgrade
	* Yes Paul it does
	* Alright so we are going to do a commit, grab my old code and proabably write a tutorial in here, then proceed to do what exactly?
	* Well we then have the database migration so we can calculate the hash easily
	* Good what else
	* Then we actually get to work on the API logic
	* 
* 2023-01-24T14:08:09-05:00
	* Alright what's next?
	* Ummm you have a TODO list
* 2023-01-24T11:18:06-05:00
	* So where do we start?
	* Hmmmmmm
	* We have our DB object, do we write the API endpoints in express or do we experiment with the database and input dummy data
	* API endpoints
	* Alright tell me a story, does index.js take in CLI arguments?
	* YES of course
	* What are they
		* Reset
		* Database
		* Port
	* You know same as database.js
	* Alright are they needed now?
	* No but just add it in 
	* Then add all the express endpoints
	* Then do basic inserts with them
* 2023-01-24T11:21:39-05:00
	* So how do we make sure the database is up and running before we process requests and stuff?
	* Good question, check database connection if statement?
	* Or do we put the entire express app inside of a function
	* An express app inside a function sounds dumb, let's have an if statement.
* 2023-01-24T11:24:06-05:00
	* Do we want lower case or upper case API endpoints
	* No one does upper case API's, do lower case
* 2023-01-24T11:31:48-05:00
	* Alright we got out API endpoints
	* What now?
	* Well we need to do the AUTH stuff
	* Okay so we decided to not do session cookies unless they actually tried to login
	* In real world no always use session cookies
	* Alright so we have a series of problems
	* How to set cookie
	* How to test setting cookie
	* Wait we should request a cookie then allow the cookie more privileges rather than doing the auth
	* Ya that's the correct way
* 2023-01-24T11:58:25-05:00
	* Alright we have the endpoints
	* Alright here is your plan, figure out the cookie generation, saving and verifying
	* Then you can do the actual application
	* So how do we want to do this?
	* Well the correct way is to sign stuff on both sides
	* This is POC, generate on backend and save to database
	* Generate it how
	* UUID Generation, figure it out
	* Does the DB do that automatically?
	* Test it out
* 2023-01-24T12:01:46-05:00
	* Is it a good idea to troubleshoot stuff you don't know in the API itself
	* Why not
	* Alright go ahead

## [2023-01-23](/2023-01-23)

- 2023-01-23T17:54:14-05:00
	- But we also need models
	- We have a async problem
	- Make the function async bro
- 2023-01-23T17:31:04-05:00
	- This is sad, I can't replicate what I did years ago
	- Well now you have a direction go with it
	- We want to play with the sequalize object in other files
	- So how does this work in the end?
	- You export the final sequalize object
	- Okay so our script can't really do anything if we can't input the connectionString
	- Yes idiot, now is that connection string in a file, env_variable, or hard coded.
	- Right now you have this script that deploys the database and even over writes it
	- So you want a class you can import, feed in the connection string, then access all the users and crap
	- YES
	- There should be a function that input's the options and outputs a sequalize object ready to be played with
- 2023-01-23T15:23:02-05:00
	- What Token are we dealing with?
	- Do we really wana set a cookie when we don't need to, we should only set a token when we wield persona, otherwise it is just too much
	- So we removing the /GET_TOKEN part
	- YES, dude why
	- Okay so now what?
	- Ummm we do wield persona
	- Alrigh, we documenting each of these end points
	- Ya we should
	- Why
	- Track thinking, this is not docs then code, it is DEVELOP, make sure you make the right decisions, Alright
- 2023-01-23T15:26:09-05:00
	- What is the purpose of WIELD_PERSONA?
	- To login
	- So we have three key's, data, hash, and signature_of_hash
	- Ya that's what we got
	- Cool so now what?
	- Ummm do we code the test for it first?
	- Also how do we store the cookie for testing
	- That's a good question
	- Should we actually get an EXPRESS template from the docs and stuff?
	- Ya we probably should
	- We should watch something on testing
- 2023-01-23T15:37:03-05:00
	- Alright so do we wana write the test or the API first
	- Well we should write the API
	- Alright write the express code
	- We should also have a file or something from [dentropydaemon-wiki/Software/List/hoppscotch](/dentropydaemon-wiki/Software/List/hoppscotch)
	- How do we want to deal with the database
	- We need scripts to reset and seed
	- So when we run index we should look for environment variables
	- Ya so we need a database right, so we read in the environment variable, if there isin't one we just use sqlite, sound good?
	- Ya sure who cares
	- Yo bro your schema code uses an in memory sqlite database
	- Why don't we use that for now
	- So are you going to take command line arguments into index.js
	- Ummmm no
	- So you run index.js and what happens?
	- Connects to database
	- Test's Database
	- Then run's API
	- So this tests of database where do we want this?
	- All one file for now we pull stuff out later.
	- Wait what's the proper way to do this?
	- Pull an object from the schema.js file and play with it other places
	- Ya you should just like import the database
	- What would an example project be
	- This project start's the server then connects to the DB, [full-stack-blog-example/app.js at master · misztijanos/full-stack-blog-example](https://github.com/misztijanos/full-stack-blog-example/blob/master/app.js)
	- I am over thinking this.
	- We test the database, that's it
	- Ummm our schema file is creating the database and everything
	- Ya 
	- So what do we do?
	- Use sqlite on disk now I guess
	- Sure
- 2023-01-23T15:54:30-05:00
	- Alright we got something
	- So what is the story for development?
	- Do you have to insert into the database what you got
	- Then you can seed the data however you like
	- THen you can reset
	- So when you run Schema what happens?
	- It should take CLI arguments
	- What CLI arguments
	- Connection String, Reset, and Seed
- 2023-01-23T16:37:20-05:00
	- Alright we need to feed the sequalize stuff into the schema script
	- It seems like I need to have the sequalize model defined before I am allowed to play with anything
- 2023-01-23T16:45:29-05:00
	- It is clear to me Sequalize will not work without sequalize being defined
- 2023-01-23T16:54:16-05:00
	- Alright we got ourselves a schema
	- But we do not have the right table names
	- Are we going to hard code the table names?
	- Yes
- 2023-01-23T17:01:08-05:00
	- Alright what's next?
	- Ummm how about an express server, ya
	- Or recompile as vite project
	- Ya let's do a vite project
- 2023-01-23T17:29:09-05:00
	- Alright we got our database and stuff
	- Well now connect to it from another file
	- Shit I am an idiot

## [2023-01-22](/2023-01-22)

* 2023-01-22T22:05:38-05:00
	* Schema 0.0.7 we are on
	* Alright so the meme contens get hashed an linked
	* YES
	* And the content does not include the transactions
	* TRUE
	* Alright we should be good now
	* We proof reading the Schema
	* Nope fuck that, we impliment API and find the mistakes
	* We should proof read, I don't feel like it though
	* Alright what else
	* Hmmmm I think this POC will work out, it will at least look pretty nice on my resume
	* Oh ya how would you reskin this with different AUTH
	* Dude that auth table can be played with pretty easily
	* Ah nice cool
	* Now what's next
	* We git commit
	* We go on a walk
	* We get bubble tea
	* We implement API in express
	* YES, do all those things
	* Yes do all those things
	* What about assigning people quests?
	* Isin't that what a Question is
	* hahahahah
	* Making jokes with myself
	* Where we pushing this?
	* Keybase for now?
	* Sure dentropydaemon
	* Sure who cares
	* No we do not want to show this off
	* Only daniel will see and we already imagine him seeing this stuff
	* Alright do it
	* keybase://team/dentropydaemon/question-engine-backend
	* Boom it exists
	* At least now my computer can't crash and take everything
	* Paul go on a walk
	* 
* 2023-01-22T21:47:43-05:00
	* Wow we are on Schema 0.0.6
	* And still making changes
* 2023-01-22T21:43:52-05:00
	* Alright so what's next?
	* Well we have BALENCES, USER_TOKEN, TOKEN_OWNER ohhhh
	* Can we do Blacklisted within here?
	* YES
	* We can have different settings
* 2023-01-22T20:56:33-05:00
	* So for USER_PSEUDONYM_HIST_T
	* Do we want DATE_SET and DATE_CHANGED
	* Ya that's what we want
	* Or do we want SET_TRANSACTION_HASH and CHANGED_TRANSACTION_HASH
	* That works better, the transactions have the dates
	* DO we want the public key that signed?
	* No that is in the transaction's
	* Wait why do I have HASH_OF_MEME
	* WHAT IS THIS that is not a UUID
	* Proof read my friend, this is why you are horrible at it
	* Dammit Paul, I thought this thing was perfect
	* You were wrong
	* Another version change
	* Sure, alright so do meme's have a UUID I generate or a transaction hash?
	* Well all meme's are created via transactions right?
	* YES
	* So you can use a transaction hash
	* Do you have to spend token's to have a meme?
	* YES
	* Alright then there is a transaction hash
	* What about update updated memes?
	* Meme's have a code that can be updated bro dw
	* So this is a string now
	* YES
	* Date of meme no longer matter's cause you can search it in the transaction hash.
	* Too many join's bro
	* We first normal form bro
	* So it looks like we are going to get some serious transactions in this shit
	* So meme's need currency backing them, so does the transactions backing them come first or the meme itself
	* The transactions hashes should within the meme, but it also has to be signed.
	* So the Transactions are those JSON that should be tracked as well?
	* Hmmmmm probably YES
	* So the MEME content is Signed WITH THE TRANSACTIONS
	* YES
	* You reap what you sowe
	* SO we have meme content, we also have transactions within meme
	* But that transactions might be a meta transactions
	* Well it should be
	* So we doing a meta transaction table that goes up to 12 transactions
	* Fuck that
	* So JSON
	* Okay Explain to me why the transactions get signed then the meme get's signed
	* The transactions get signed up the hash of the meme_content, then the signatures of the transactions are added to the meme
	* So the transactions referencing this meme can be queries separately.
	* We need the JSON for the other transactions to recreate the entire contents of the hash
	* Nah store that in the TRANSACTIONS_T, but we should know the number of transactions that go with the meme.
	* Do we just assume they are sorted in an array 
	* Ya sure why not
	* Wait how do we source meme's and stuff
	* Okay let's get some strings strait here
	* First we have the content of the meme hashed
	* Then we sign a bunch of transactions that mention this data hashed
	* Then we include the transaction hashes of those signatures in with the original meme and sign it.
	* Then we apply to put them all on the blockchain at once
	* What is this TAG_TYPE?
	* EDGE_TYPE?
	* Well we want tag's, do we want tag_name's
	* We want a unique identifier that can be extracted, how's about that, a name for the connection rather than a hash but something that can appear more than once, that's a tag
	* We do not include the sigantures in the MEME or EDGE MEME's do we
	* No that's for the transactions table
	* Alright so the TRANSACTION_CONTENTS should be there right
	* Well you gota sign some data, and it might as well be JSON
	* Wait so we need two transactions to do a key rotation one from the old key and one from the new key right?
	* YES
	* Ummm so we can just replace this with transactions right?
	* Ummm do we want to have the public key's and pseudonym's when it changed
	* Well that's what the ID is made of so YES, who in the world wants to join that?
	* So second normal form?
	* Dude you don't even remember what that means
	* OLD_PKEY_TRANSACTION
	* NEW_PKEY_TRANSACTION
* 2023-01-22T20:47:42-05:00
	* Why do we have DATE_SIGNED
	* Cause they are updated at different times
	* Wait we need to fix this
	* Shouldn't we get some TRANSACTION_HASH's in here
	* Ya why have the date have the TRANSACTION_HASH
	* So we should have a default transaction for registering users
	* Ummmmm YES it should technically be on chain. You don't say your name unless there are other people to hear it,
* 2023-01-22T20:30:12-05:00
	* Alright what's next?
	* Well the API seems okay ish
	* The schema checks out
	* The user stories are updated but still mostly in my head, I would not want others to read them right now
	* We really need a one pagers, design brief thing
	* Add that to the TODO list
	* Done
	* What next?
	* Umm make a empty git repo!?!?!?!?
	* We separating the backend and frontned?
	* Umm shutup premature optimizations
	* Cool so I will call the folder questionengine
	* Sure whatever floats your boat
	* No question-engine
	* So we create SEQUALIZE schema
	* Then we develop API
	* Then we have tests
	* Then we have script that creates users and shit
	*  Then we go to bed happy
	* Awww I wanted this done today
	* Then stay up, no one is watching you, you are not a child anymore
	* Alright
* 2023-01-22T20:20:05-05:00
	* Alright you need to have your own token's to ask questions, you also need other people's token to answer their questions. So we need to be able to do multi transaction. Ah the Cardano Way whahahahaha
	* So change status code for transactions
	* Let's just double check them
	* So the problem is transactions can send multiple tokens
	* We want this to be simple
	* Well Umm I guess TRANSACTION_HASH can't be unique then
	* Or do we do multiple signatures
	* Multiple signatures bro that makes life much more simple
	* Alright atomic is the way to go...... for now Cardano batched transactions whahahahahaha
	* That's so cringe
	* It is better to have a coherent conversation in your head than actually be mad
	* Also who else cares about this shit, I have no one to talk to this about
	* Alright so the faucet is a thing now so we goochie
	* Alright what's next?
	* Umm impliment the schema?
	* No double check the API
* 2023-01-22T20:06:41-05:00
	* Should we have users setup their faucet or have it there by default
	* The faucet is closed, it should be setup
	* Gotta turn the faucet on
	* It is on by default dummy
	* That is open to bots and spammers
	* It should be turned on and filled up by the individual
	* We can have a popup for this
	* When in the user journey do we have them turn on their faucet
	* After they ask a question of course
	* Alright well we can add that component to the list
	* No that's getting confusing
	* Add it to the story 
* 2023-01-22T19:57:23-05:00
	* Hahaha I linked the clip from Network, my cringe lord essence is coming back
	* The phrase Edge Lord is interesting
	* Alright what's enxt
	* Dude you have a TODO list stop asking
	* Oh we need to finish rough copy of API documentation
* 2023-01-22T19:34:38-05:00
	* Alright Schema is updated
	* Alright so we still need to send value
	* So how do we discover others
	* Well their root questions are transactions right?
	* Do we require people mint their own tokens to ask themselves questions.
	* Well that sounds stupid
	* But shows that people have their own value, it is a move of endeerment
	* It is like saying I love you
	* It is like saying Fuck you I have value
	* Oooo where is that video
	* [Here](https://youtu.be/MRuS3dxKK9U)
	* Wonderful
	* So what's next?
	* Okay we just made a decision that does not fit with your user stories.
	* There is no asking questions without first issuing yourself currency.
	* Yes the flow makes sense.
	* You have to spend your own currency before other's will give you theirs.
	* Alright we updating the user story?
	* We probably should
	* Update what exactly?
	* The prompts for the screen and stuff need to be updated
	* Shit that's right
	* Alright that's the correct answer
	* Also this way you get the transactions done correctly?
	* Hmmmm what about the transactions done correctly?
	* Ummm isin't it weird how bitcoin just kept growing, it seems to have a will of some sort
	* Not on topic
	* User stories bro
	* So what do we update that to?
	* Ummmm
	* That'e better
	* Now we need to do a check on the Your Persona screen.
* 2023-01-22T19:24:28-05:00
	* How about you have to attribute your own worth when you register
	* Ya no hiding
	* No we need hiding
	* When you sign up you show people who you are and say your name
	* Oh ya issue token stuff
	* So the token is issued via signing pseudonym and public key
	* So that should be in the transaction
	* YES
	* And it should be tracked in transaction_t
	* Should MEME_LINK and MEME_EDGE_LINK be one thing
	* Hmmmm
	* Sure
	* It makes more sense this way, it is explicit
	* Okay
* 2023-01-22T18:57:19-05:00
	* What if we want to tag our tags?
	* We should be able to script retagging and the edges should go through meme's
	* MEME edges should flow through memes, aka be transformed
* 2023-01-22T18:50:56-05:00
	* Alright that works
	* What's next?
	* We can submit memes, and meme edges, login, get a cookie what am I missing?
	* Well
		* Request_persona
		* Discovery
		* Query User
		* Perform Transaction
	* Alright so for Request Persona, we have all this data we want 
	* Alright so we want 
* 2023-01-22T18:41:15-05:00
	* So how do we link everything if we just submit meme's?
	* So a meme can reference one other meme
	* Ya why not
	* Where is that in the schema
	* Well
	* Let's think about this
	* If I ask what is your name
	* And you respond to is with a statement
	* The fact you responded needs to be saved somewhere
	* What if you want to answer other verions of this questions
	* Well we can do MEME links
	* We need the edges or the meme's are meaningless
	* Wait how do other people identity the message and stuff
	* Well umm, is there a DID format?
	* How about PSEUDONYM#PUBLIC_KEY@MEME_UUID:MEME_EDGE_UUID
	* Ya we are going to need identifiers no matter what way we put it
	* Alright
	* Cool
	* So what's next?
	* Ummm we need to know what JSON we want
	* Call it extra?
	* No
	* edges?!?!?
	* YES
	* Why can't we submit a series of meme edges
	* Well those are separate transactions
	* Dude THIS IS POC
	* Zero code written
	* Stop making things complicated
	* Should we require all meme's to connect to another meme?
	* If your meme connects to itself the graph database would store it as such rather than null
	* It's an edge bro, treat it like an edge
* 2023-01-22T18:25:14-05:00
	* Alright so ummmmmm
	* Can we finish the backend tonight
	* Maybe Database
	* Dude if you could not do that in 20 minutes I would be mad at you
	* Even with Sequalize
	* Will still be mad
	* So what comes next?
	* We specify more about the API endpoints INPUTS
	* What information do we want to request when they wield a persona
	* Just the time, date, and SIGNING_KEY
	* Is that good enough?
	* Sure why not
	* Do we want to hash the data then sign the hash
	* Yes we already know how to do that
	* Okay good
	* Wait can we have create and wield be the same endpoint?
	* Well one requires checking the other does not
	* Well it does require checking
	* Alright we remove Create persona, only wield
	* That's nice how things are simplifying
	* So what are meme's made up of
	* Ummmm
	* Tag's
	* Yes tags
	* What else
	* Content
	* URL's
	* Wait so what is a URL
	* A url is a Edge to content
	* No a URL is an identifier for a meme
	* Wait no we are supposed to do this simple
	* So we have a body
	* Wait we the code and stuff
* 2023-01-22T18:13:39-05:00
	* Alright what's next?
	* Hmmmmm RBAC
	* So we doing group's and stuff in the SQL database
	* You know sqlite does not have users and stuff
	* Your point is
	* We need to do this in raw SQL
	* How about permissions like
		* only people within thread
		* only people within X degree of thread
	* That's too complicated
		* PRIVATE
		* ONLY OP
		* X Degree (SHIT WE ARE IN GRAPH TERRITORY)
		* Show a certain number of people
	* This needs a user story
	* [Meme Permissions](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/User%20Stories/Meme%20Permissions.md)
	* Those meme permissions are going to make querying the database hard
	* I thought you could think in SQL Paul
	* Alright FUCK YOU Challenge accepted
	* Plus we left the right part of the API empty
	* Well fix that, you need to code this API, then write TESTS, Then have a setup script with test data and crap, and then have a script to reset the environment
	* Wait this goes in the TODO list
* 2023-01-22T12:31:25-05:00
	- We reread user stories
	- List features on screens
	- Then list all components
	- Then reread user stories
	- Add additional user stories, short ones
	- GET TO CODING
- 2023-01-22T12:52:52-05:00
	- Should we have Your Perosna rather than profile
	- Absolutely
- 2023-01-22T13:20:23-05:00
	- How do we deal with viewing other people's persona's with the 4 tabs, viewing a persona is a separate tab.
	- Someone will be able to navigate into this component from Discovery, Quest(ion) Logs, or their Profile Page
	- Wouldn't it be cool if these other Persona's showed up along the top like Tabs
	- How dam that would be cool
	- That is too complicated for POC
	- We can just have a persona view tab that get's populated with the contents saved.
	- Ya that would make things simple
- 2023-01-22T13:34:04-05:00
	- I am getting too grandular, the user stories are in my head, I should just get to coding
	- Plus the user stories will make more sense as you you code it
	- And I can organize the ACTUAL components and stuff
	- Alright let's learn to code once again
- 2023-01-22T13:39:09-05:00
	- OODA
	- Alright where do we want to be in an hour
	- We want to be stuck on the metamask stuff
	- Shit we need the database as well, we should do the API first
	- This is what priorities are about
	- Alright Schema time
	- That will help with the user stories
	- READ USER STORIES TOP TO BOTTOM and DO NOT EDIT THEM unless it is grammer or something simple
- 2023-01-22T13:52:14-05:00
	- Oh ya do we want to request tokens from user before you can even respond to them
	- Why yes this is raw tokenized attention
- 2023-01-22T13:55:39-05:00
	- Wait do we want every message sent to be signed
	- Of course we want people to know stand behind their words.
	- Oh ya we already made this decision
- 2023-01-22T13:59:46-05:00
	- We should have Who Are You be the profile description.
	- Yes that fit's the theme
- 2023-01-22T14:01:31-05:00
	- Alright
	- We should use Draw.io or something
	- Can ExceliDraw do this
	- OMG look what I found, [zapthedingbat/drawio-obsidian: Draw.io plugin for obsidian.md](https://github.com/zapthedingbat/drawio-obsidian)
- 2023-01-22T14:18:02-05:00
	- What do we want to do with old signed data
	- Logs bro, logs, that's what a logs table is for bro
	- Hmmm do we want to have public_key in multiple places
	- No
	- Why do we have DATE_SET for USER_T
	- We need one for PSEUDONYM and PUBLIC_KEY
- Do we want a PUBLIC_KEY_HIST_T
	- YES
	- Wait PUBLIC_KEY_ROTATION
	- YES
- Alright should a description table exist?
	- NOPE
	- We should only have a question table and the question should be "Who are you?" is what fits in the description
	- Alright we have questions and comments, separate tables?
	- Nope question verses comment are just metadata tags
	- Then we are doing to have tags
	- Of course
	- We need graph database
	- SHUT UP
	- We need a primary key
	- Wait should the BEARER_TOKEN be the Pirmary key for AUTH_T
	- YES dummy
	- Wait BEARER TOKEN UUID
	- Why not, this is POC and we lazy bro
	- Alright what do we want to call this?
	- We have to track the meta constructions and then the actual metadata
	- What if a word for question and comments
	- Phrases?
	- No
	- Hmmm what would be good
	- CONVERSATIONS_T
	- No those are meta constructions
	- PHRASES_T
	- Let's ask ChatGPT3
	- Paragraph's
	- No, Sentences
	- What are the components of langauge
	- Sayings
	- Those are for specific things
	- Invent a new word
	- No that is stupid
	- These are like tweets
	- or toots
	- Messages
	- Well we can call them messages in the backend
	- Ya that works
	- But these are messages with context
	- They don't have context yet
	- What are the components of context?
	- QS - Question Statement
	- No
	- Is this important
	- YES the language we use is important
	- COMPONENT_T
	- The components of context?
	- No
	- Memes
	- Ya that works
	- Is MEME Content just VARCHAR or JSON
	- Well the content should be VARCHAR Markdown
	- Then we should have metadata
	- Alright that works
	- How do we edit memes and stuff
	- This should be append only and stuff
	- Well we need MEMES_T and MEMES_HIST_T
	- Ah I see
	- So whomever controls the root meme can choose to display how it works
	- No these are meta memes, like root questions
	- Root questions are meta memes.
	- Do we have memes and meta memes in the same table?
	- No meta memes need to be different
	- So what if we edit a meme
	- MEME_HISTORY_T
	- We have to query that one if it is updated
	- So UPDATED is Boolean
	- Do we want to calculate the change in the meme?
	- No this is ETL stuff, it is too complicated, we don't even know what we want yet
- 2023-01-22T14:50:30-05:00
	- Do we want DATE_UPDATED
	-  Now are we doing tags now?
	- Or are we doing Meta Memes?
	- Do we want meta memes to be like Key Value, just get the entire context of a meta meme
	- Well we want to have meta memes have a limit in size right?
	- Yes but that is a join problem. Do we want the Meta Meme to connect to 100 memes YES, we also want it to connect to 
	- Well there aren't any root memes
	- Yes there are
	- Alright all meme's belong in one table
	- META_MEMES are for connecting them
	- Dude this is classic graph database shit you are doing right now
	- THIS IS WHY GRAPH DATABASES EXIST
	- Well Ima show that SQL can do it all
	- Alright so we have root questions asked by someone
	- Dude root questions are TAGS weather or not something is a root meme is a TAG you need a TAG table, and you can have reserved tags such as LINKED which say that the tag is LINKED you know. Like the special codes you have in your work database.
	- Ahhhhhh that works.
	- Wait how does this TAGS_T work
	- We still need a unique key here don't we
	- Dude just call it EDGE_ID
	- Ya this is graph stuff
	- Let's check my [dentropydaemon-wiki/Software/List/neo4j](/dentropydaemon-wiki/Software/List/neo4j) notes
	- Nope those do not describe the core terminology of graph databases
	- [dentropydaemon-wiki/Software/Catagories/Database/Graph Database Software](/dentropydaemon-wiki/Software/Catagories/Database/Graph Database Software)
	- Nothing there
	- [Graph](/35f29bc3-ad1f-4ea8-b6bc-7fbc33413c73)
	- Where is that Graph Database terminology video I remember
- 2023-01-22T15:10:10-05:00
	- Alright so we have nodes and edges
	- So the tags are like edges that allow the edge to refer to itself
	- Dude just use a graph database
	- No I already got my schema and SQL is idiot proof
	- Twitter has this figured out with their quote tweets and stuff
	- You do not modify the original context 
	- Well the context yes
	- What about when people edit tweets
	- Alright you do not delete your answer you update your answer by REPLACEing
	- Ah that makes sense
	- Dude this is basic graph shit
	- I just want to say that a bike HAS wheels
	- Oh we just need a root meme, like a zero meme, similar to how applications in the [dentropydaemon-wiki/Software/List/EVM](/dentropydaemon-wiki/Software/List/EVM) send stuff to the ZERO address
	- The root meme is Zero, that's it Everything links to Zero
	- [dentropydaemon-wiki/Media/List/Zero to One](/dentropydaemon-wiki/Media/List/Zero to One)
	- LOL sure why not
	- Alright all memes link to zero, it is the root
	- Or do we call it root
	- Hmmm does this matter
	- The symbolism matter dude, this app you are developing is not even special
	- The root meme has too much associated with it, people want different roots
	- Well you are going to have all these root memes anyways
	- Root memes do not stay root memes they show up and get MERGED
	- MERGED into what exactly?
	- Hmmmm the tree of knowledge
	- Is that a real meme
	- Oh fuck that is [Gnostic](/6f4da628-929b-4e52-9399-e2ef45f8fbd6) bro
	- Sorta scary actually, those people hate the material world
	- Actually growing the tree of knowledge when using Quest(ion) Engine
	- The fact that this symbolisim writes itself makes me think I am onto something for once
	- Alright so all memes have to link to another meme but there is a root meme, or we can just have the value in the database be null
	- Ya null in the database makes sense
	- So we should have this like MEME_CONTEXT_T, we can have a SOURCE_MEME, REFERENCE_MEME, EDGE_CONTENT
	- Do we just want all meme context to be JSON, like come on it makes shit simpler
	- Ummmmmmmm ya it totally fucking would
	- Are [dentropydaemon-wiki/Software/List/Keybase](/dentropydaemon-wiki/Software/List/Keybase) messages JSON with metadata
	- YES
	- Alright then do JSON
	- Wait we have MEME_CONTENT and MEME_CONTEXT
	- Dude those are supposed to be separate, MEME_CONTEXT can link to the other meme's
	- Alright they are both JSON
	- Okay good
	- REPLACED is what we are looking for
	- Alright we can have a REPLACED_MEME_ID be null or not
- 2023-01-22T15:21:46-05:00
	- Alright what's next
	- We gotta figure out this MEME_CONTEXT_T table
	- So we have a SOURCE_ME and a USER_ID right
	- YES
	- MEME_CONTEXT_ID!?!?!?
	- YES
	- Wait should we use USER_ID in all columns so the UUID's don't get confused
	- ABSOLUTELY WHAT WERE YOU THINKING
	- Wait is we have MEMES_HIST_T tracking the history of a meme we can't have the MEME_ID be unique
	- All meme's should be UNIQUE
	- What terminology were we doing?
	- Alright so we have a MEMES_HIST_T
	- Okay so when you replace a meme it updates the context and stuff across the board?
	- Shouldn't all meme's be in the same table then
	- YES MEMES_HIST_T does not need to exist anymore, REPLACED_MEME_ID will be there or not, we will just be doing a simple update on the table right
	- YES that's what we are doing
	- Do we want to update the table
	- We gota update something this way is simpler.
	- Alright so we have meme's that can get replaced by other memes.
	- Wait what do we need the MEME_CONTEXT column in MEMES_T for if we have the MEME_CONTENT in JSON
	- Ummmmm let's figure out MEME_CONTEXT_T first
	- So we need what in MEME_CONTEXT_T?
		- Remove meme context
	- Dude stop for a second, you are designing a Schema without a fucking user story or use case
	- No I have a use case
	- What is it
	- RESPONSES how are the questions and statements linked together and stuff
	- Alright so when RANDY responds to STACY the MEME_CONTEXT table has that as a reply
	- You know you should have columns of stuff that get's turned into JSON after not like in the database itself
	- This is a POC we will not even use SQL later, especially if it is written in [dentropydaemon-wiki/Software/List/Hoon](/dentropydaemon-wiki/Software/List/Hoon)
	- Alright so meme context needs SOURCE_MEME and CONNECTION_MEME with a TAG_NAME
	- What about deleted meme's and context
	- Add column
	- Status Code, so we can have RBAC
	- Alright do that
	- This shit is basically [dentropydaemon-wiki/Software/List/Tiddly Wiki](/dentropydaemon-wiki/Software/List/Tiddly Wiki)
	- Social Media Tiddly Wiki with a User Journey
	- Alright sure
	- It turns social media itself into a graph
	- Does this work as a DAG
	- YES
	- Ohhhhhhhhhhhhhhhhhhhhh
	- So how do we choose the context.
	- The owner of a meme should be able to update the context around it
	- Well we have a status code for updated context rather than actual content
	- PAUL STOP
	- You need user stories all you have is people asking like two questions
	- WHO ARE YOU DESIGNING FOR?!?!?!?!?!
	- I wana have debates using this tool, so I want to be able to say something like God does not exist then go back and forth coming up with an eventual definition of God
	- You wana debate weather God does not exist
	- No, I wana ask what is your definition of God, we know the Atheists have their own God. The GOd of Soyence, They view themselves as God
	- Alright that may be an interesting conversation
	- You can probably put [dentropydaemon-wiki/Software/List/GraphQL](/dentropydaemon-wiki/Software/List/GraphQL) in front of this 
	- DUDE THIS IS POC, I really wana try out [dentropydaemon-wiki/Software/List/SurrealDB](/dentropydaemon-wiki/Software/List/SurrealDB) or [dentropydaemon-wiki/Software/List/GunDB](/dentropydaemon-wiki/Software/List/GunDB) or [dentropydaemon-wiki/Software/List/EdgeDB](/dentropydaemon-wiki/Software/List/EdgeDB) among others. You are over optimizing. Over optimization = Death
	- Alright so we have meme's and meme context
	- But we can't link to multiple meme's
	- Why would you want to do that
	- Hmmmmmmmmmmm
	- USER STORY missing
	- YES
	- Alright let's take a look at how I am using Obsidian where do I like to join multiple meme's. I just have a meme and make connections to it.
	- Ah so this is like how, like how, like how nature chooses to route water. It finds the easiest path forwards it's goals.
	- What are the goals of this system
	- Shut up not now, that is for walk later
	- Alright alright
- 2023-01-22T15:47:25-05:00
	- Okay where are we
	- Is this schema large enough to bootstrap a new kind of social network
	- Ya
	- It is not different than twitter
	- Can you label the tweets you recieve and organize the order of who responded and stuff
	- NO
	- That is the MEME context
	- Wait people might want to have separate meme contexts
	- Like you can have a meme and your friend could have provided context for it
	- Oh shit USER STORY time
- 2023-01-22T15:50:11-05:00
	- Alright what's next
	- We organise the user stories
	- Alright so we now have [The Fight for Context](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/User%20Stories/The%20Fight%20for%20Context.md) user story
	- What is this context, should we call MEME_CONTEXT MEME_EDGES
	- Ya that makes way more sense
	- Alright now this context what is it?
	- Right now it would be a specific way of displaying a thread or something like a mindmap
	- A context is a specific subset of a graph, it is like a query
	- Does the Author provide their own context
	- They can, Meme's can come with their own CONTEXT
	- Alright but we can have a competing context table
	- Alright and what would be in this table
	- Well would this be like a MEME_EDGE or a separate meme
	- Well meme context is just a metameme, that's literally what it is
	- Write a story about a meta meme.
	- A meta meme would be like a Wikipedia Article
	- So in conversational terms that would be a what exactly?
	- That would be like having someone say who could speak first during a debate
	- Is this needed for the POC
- 2023-01-22T16:10:54-05:00
	- Alright we filled in [The Fight for Context](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/User%20Stories/The%20Fight%20for%20Context.md) user story
	- Well the general idea is that the Conservative party could have their string of facts and the Liberal party can have their string of facts and comment on one anthers. They can also weigh what areas need the most attention.
	- So the context would consist of a collection of memes and meme edges it's really that simple
	- So is MEME_CONTEXT it's own meme's
	- Well a MEME_CONTEXT is special query on the memes. 
	- Oh it can be it's own MEME, just with a different status code
	- Can the context of a meme be its own meme.
	- YES
	- Okay we need to decide on these status codes
	- Well do we need the MEME_CONTEXT column now that we have MEME_CONTENT
	- NO
	- This is just like the different message types in [dentropydaemon-wiki/Software/List/Keybase](/dentropydaemon-wiki/Software/List/Keybase)
	- Yes yes it is
	- Alright so we just have a MEME_CONTENT graph.
	- So do we need a MESSAGE_CODE column as well
	- YES
	- So ummm how do we decide what the default context it
	- THE USER DECIDED
	- Alright whatever that is too far down the line we need to know the different MESSAGE_CODE's and STATUS_CODE's
	- Should MEME_EDGES and MEME's both have STATUS_CODE column's or should they be MEME_STATUS_CD and MEME_EDGE_STATUS_CODE
	- Ummm do they have the same STATUS_CODE's
	- NOPE
	- Alright so rename them
	- YES, mission acomplished
	- Alright sooo what next?
	- Ummmm what kind of meme's do we have?
	- Yes we need these CODE's
	- Wait can we change message code
	- YES, we need to track that in HISTORY
	- Nope we don't we have REPLACED_MEME_ID
	- Cool
	- SO we impliment schema now
	- NO we have to decide on these codes
	- Where in the Schema folder or the API folder?
	- There is no API folder
	- Well this seems like an API issue
	- Meta?
	- No
	- Root folder for project
	- No
	- Database Codes inside schema
	- YES
	- [Activity Pub](/c1a79e55-46b3-4070-9271-4cbee6a61fec) Engine]]%20Engine)%20Engine/Schema/Database%20Codes%20-%20Quest(ion)%20Engine.md)
- 2023-01-22T16:25:10-05:00
	- Is meme code even right?
	- Why not it sounds cool
	- Maybe we want meme type
	- MEME_TYPE_CODE
	- Ya that works
- 2023-01-22T16:27:59-05:00
	- Let's have a conversation on Tags for a second
	- Should tags be meme's an individual creates and then link everything that uses that tag to
	- Well are tag's statement's or questions
	- Tag's are statement's
	- So you are linking everything to a statement
	- Yes
	- So the UI can have a Tags section where it asks, add your tags here
- 2023-01-22T16:31:09-05:00
	- Alright what types of memes do we have
		- Content and Context
	- Well that sucks for creating code's for them
	- Just store entire strings there
	- No that does not seem cool
	- How about CN and CX
	- Don't you hate acronyms
	- But we literally say codes
	- Well that works
	- And we will write the documentation so when you search that you know what it is very easily and stuff
	- Alright do it
	- Wait we also have statements
	- No we have Question, Statement, and Context
	- Ah that's what we were forgetting 
- 2023-01-22T16:36:57-05:00
	- Alright we got ourselves a Schema
	- A schema that does not have any update queries and stuff
	- Paul, you need to understand that this think you think is so great only exists in your head. Unless you can articulate perfectly no one is going to give a shit and your corpse will rot away forgotten.
	- Shit bro that's fucked
	- Alright so we have the schema, is it API time
	- YES
	- [Logs - Holium Proposal](/dentropydaemon-wiki/Projects/Quest(ion) Engine]] Engine](ion|[ion|API - Quest(ion|[ion|[ion|[ion|[ion|[ion) Engine]] Engine]]%20Engine)%20Engine/API%20-%20Quest(ion)%20Engine.md)
	- Ooooo I see something interesting, we already worked on it
	- What was our answer to root questions like WHO ARE YOU.
	- Oh ya we need root memes in the Database Codes
	- Alright added
	- API time
	- Alright so we have Auth, Update Profile, Update Pseudonym
	- Wait the Pseudonym is just a question right!?!?!?!?
	- Well the user picks a name and stays with it, people have a name, you can ask what is your name and change it and stuff.
	- Pseudonym needs to be there as part of identifier, Discord needs a primary key. We will use the NFT later on anyways.
	- Dude this info does not matter. Also you should not be able to update your Pseudonym.
	- Why not
	- You are supposed to get a new identity, a new account. You can change your description and handle name though.
	- Alright, and there has to be a context that transition's all this data
	- Yes just like with [2023-01-21](/2023-01-21) when people swap servers they can forward people to their other account.
	- Yes and this will all be fixed with NFT's that allow proper rekeying
	- Alright cool this works
	- Wait from the top how does this work
	- Wait we need bearer tokens even for people that are not signed in
	- Does the database work with that?
	- No we can just have the USER_UUID be blank and issue a new BEARER_TOKEN once they login
	- Alright that works
	- Wait do we need MEME_CONTET attached to the meme, we need to know if the meme was in response to another meme initally
	- DUDE JSON, that's what that is for, that's also why we have the root status codes
	- Alright so the context does not always have a signed message
	- Shit did we forget to sign the data
	- Ya
	- And should we hash it then sign it
	- Ya probably
	- Time to update the schema
	- Wait should the HASH_OF_MEME be the MEME_ID
	- Why the fuck not
	- Alright what are we missing?
	- Okay so if I respond to a meme how do they get linked?
	- Well I submit a meme the MEME edge should automatically be created regardless, I should not have to sign something more
	- But what about when I create my own edge
	- Alright those need to be signed
	- So MEME_CONTEXT_ID, no that should be MEME_EDGE_ID
	- Okay what else?
	- Hmmmmmmm
	- Can people comment as an edge?
	- Ehhhhh YES
	- Why would a edge apply back to itself
	- It's not a tag, the meme should be updated, comments should be statements or questions, no refering to self unless is a tag.
	- Wait can MEME Edges be replaced and and stuff just like MEME's
	- YES
	- Well do we wana replace it or just delete it
	- There is no replacing links there is removing them
	- No they should be updated, track the history of intent
	- Alright we have our Schema in place and stuff
	- Should I look into how Tiddlywiki does this, cause I am pretty sure I can steal their Schema and tech and stuff
	- YES this entire project could be likely built on top of Tiddlywiki or OrgRoam or something like that.
	- Ya I think I just reinvented tiddlywiki
	- But your user journey is different, you could use the same backend but the frontend fould feel different.
	- Ya it uses the same engine but is a different game
	- Also tiddlywiki is a lot of code, this should be stupid small
	- Well will the backend actually be small, look at all the different codes you have
	- Shit ya this got complicated fast
	- Can you do that in 1000 lines of code in the backend?
	- Probably not tbh
	- The schema is going to be a couple hundred
	- Alright I want this working tonight to show off to people
	- Alright so what's next?
	- API design that's what we are working on
	- So we have SUBBMIT_MEME and SUBBMIT_MEME_EDGE or something like that?
	- Sure why not
	- Wait what if people forget their Pseudonym
	- You don't forget your name bro, make a new account
	- hahaha
	- Do we get spammers wielding persona's every day
	- Then we have RBAC and have them answer a string of questions and add context, you know like for the [Holium Transaction Types](/dentropydaemon-wiki/Projects/Quest(ion)%20Engine/Logs/Logs%20-%20Holium%20Proposal.md)
	- Cool sooo what else is needed
- 2023-01-22T17:18:37-05:00
	- So how do we want to query other people and see their answer's
	- GraphQL would be really nice here bro
	- Shit you are right bro, but this schema will work nicely inside graphql anyways, and I can hire a guy on code mentors.
	- So how do we want these users to query each other?
	- Hmmm how about we just have a QUERY_USER endpoint
	- Shit, that's simple and expandable
	- Yes and it will be a graphql endpoint eventually too
	- Wonderful
	- So what's next?
	- What about adding users as a friend and stuff
	- Yo where are we tracking the currency and shit in the database
	- Ya we really don't have this entire product in our head
	- Hey dude, calm down this is why we are doing raw design.
	- So we we need to add currency and transactions and stuff
	- Well these are meme's, the whole point of this project is THERE IS A FEE TO POST CONTENT AND STUFF
	- Ah the self post tag things can be free comments
	- Okay I will add in the database codes
	- Alright so how are we doing these transactions and stuff bro
	- How could we forget this
	- That's what you get for drinking last night bro
	- So we having a transactions and balances table?
	- Ya that would be pretty simple
	- Okay so for the meme's we have a signed transaction hash in the transactions table
	- No we just reference the transaction, the hash needs the data
	- Also we do not want to allow free messages with edges
	- So how does adding tags work?
	- Wait so everyone is going to have tones of different balences
	- Ya 
	- Dude no more drinking
	- Also write a proper one pager
	- Also transaction types?
	- Shit, MEME, EDGE, TRANSFER
	- Do we want the TRANSACTION_DATA and
	- Wait we do not have hashes
	- No we do this does look right 
	- Do we want burned or removed
	- Removed is when you take them away from someone
	- Burn is when you send the tokens to nowhere
	- Sould someone have to spend their own tokens to turn on or off their faucet
	- No this would be on chain transactions or payed to be on the dag later
	- Wow this got complciated fast
	- Umm ya
	- Wait how do we link the MEMES_T with
	- Do we want the TRANSACTION_DATA in two locations
	- Well we can have it be null for the right types of transactions
	- True
	- It should not be nullable
	- Dude this is a POC
	- We show this to people and they go like, Ohhhh I get it I want to use the final product
	- Cool so we have to update the API now
	- There are no friends unless you label yourselves with a question and state, there is only value exchange between people
	- What about blocking!?!?!?!?
	- Hmmmmm too complicated do later
	- Should that require a blockchain transaciton
	- YES
	- So when we do transaction we need to track if they are blacklisted
	- That means we need another table
	- What about black listing all users
	- Well we can just put NULL in TOKEN_BLACKLIST_T to solve that problem, blacklisted across the entire space, of course this would not happen on the blockchain but on instances.
	- Is this going to run on instances
	- Dude this is supposed to run on Urbit planets
	- YES URBIT PLANETS
	- That would be AWESOME
- 2023-01-22T17:59:29-05:00
	- Alright what's next?
	- Hmmm we have our schema, but do we have our endpoints
	- I don't think we put group permissions on our MEME's
	- LOL we need group and user permissions on our memes
	- Shit we are just developing unix again aren't we
	- AS above as below
	- Shit bro
- 2023-01-22T18:09:26-05:00
	- Permissions and groups need to be a thing
	- Dude this is POC you are expanding the scope too much, all questions are public
	- No the USER STORY has this shit
	- Also when people work on rocket's they have to get the entire thing right
	- Nope they can do engine tests
	- Well when people develop rocket engines they need to get the entire thing right
	- So how are we doing permissions?
	- Are we doing groups, or just public / private
	- What permissions would we wants?
	- THis sounds like a user story problem
	- 
[dentropydaemon-wiki/Software/List/System D](/dentropydaemon-wiki/Software/List/System D)

* 2023-01-21T11:09:14-05:00
	* Alright what we doing today
	* Let's move our previous notes over
	* So we have this account people make, then people create social media profiles, then people look at other accounts, then people add friends, then they get added as friends, or acquaintances in this scenario, then they get tokens for one another, then users get social media feeds including questions, we need more a social media board like a canvas in Obsidian or a choose your own adventure game. Then people spend tokens to see the other people;s questions. 
	* Alright the first problem is Auth, how do we wana do that
	* From scrach obviously, you sign something and get a cookie. Then we have a script that runs every hour or something that deletes the old cookies and that is even optional
	* No we should design the endpoints
	* What endpoints
	* The endpoints from the Holium Proposal
	* Where are those documented?
		* [view_persona - Screen](/../dentropydaemon-wiki/Projects/Quest(ion)%20Engine/Holium%20Stuff/Holium%20Transaction%20Types.md)
	* That's not what we need
	* Alright go find the old code
	* It's gone, I keep HORRIBLE LOGS
	* FIX THAT
	* Alright what is the API
	* Make a doc
	* 2023-01-21T11:16:50-05:00
	* What does a profile consist of?
	* Well what does a twitter profile consist of?
	* Umm a description, that's it, then we have the questions that are TAGGED
	* How do we deal with these tags in a SQL database?
	* Let's check how Trilium and Obsidian do it?
	* Does Sequalize support lists?
	* Tagged posts need to go in another table, that's just a fact
	* Sure no problem
	* What else do we need to know
	* Okay so we have a description, then we have questions with hidden answers THAT's IT
	* Alright I can get behind that
	* Alright we got all the API functionality mapped out
	* SIMPLIFY you can cut half these out
	* Do we decide on a schema and generate an API or generate an API and then choose a schema
	* Schema
	* 2023-01-21T11:32:47-05:00
	* Oh we forgot the tags functionality
	* No we didn't we just said search and stuff
	* Is tags too much for POC
	* For the UX yes, schema and API no
	* Just put the table in and make it part of the API
	* It is too complicated
	* Alright I will skip it for now
	* Should the description be in its own table?
	* Yes because we want to log this shit very explicitly
	* WHAT ABOUT UPDATING PUBLIC KEY
	* But we search people up based on their pseudonym, if they change it we no longer have a primary key
	* FUCK
	* Rekey new identity?
	* No that is cheating
	* This is why you had the chain thing
	* Should people verify the users key when they change
	* COMPLEXITY EXPLOSION
	* Use NFT's
	* COMPLEXITY EXPLOSION
	* We generate a unique key for each user that can be changed to a NFT later
	* What about when user wants to change NFT
	* The user is the NFT fuck that
	* Alright
	* USER_ID 
	* Sure use whatever the fuck you want
	* Alright so how do we do these questions and answers
	* PAUL YOU NEED USER STORIES
	* Fuck I am an idiot
	* Alright where do we put these.
	* You gonna setup Personas as well
	* I should have those somewhere else where I can reuse them
	* Alright USER STORIES
	* 2023-01-21T12:32:45-05:00
	* Alright the User Stories are coming along
	* We have a problem what is the first page?
	* Profile, Discovery or Quest(ion) Log?
	* It should be  Quest(ion) Log
	* What should the Quest(ion) Log look like?
	* Ummmmm
	* It should by an info graphic dashboard, well a table with lots of tabs to add later
	* Umm what MVP stop thinking in the future
	* Hmmmmm
	* It should just have raw logs, you know like [[dentropydaemon-wiki/Software/List/System D]]
	* Wait we want to have a friends area or something like that don't we
	* YES we do
	* Where do we want to put that?
	* We have a quest log, but what about something else
	* What something else?
	* Hmmmm
	* My Connections
	* Do we want a "Quest(ion) Query" area?
	* No the "Quest(ion) Log" should have different tabs for looking through it
	* Shouldn't the "Quest(ion) Log" have a different name
	* How about Quest Graph
	* No people do not think of graph's the way you do Paul
	* Timeline
	* No
	* Quest Canvas?
	* Quest Area
	* Home?
	* Quest what?
	* We also don't want messages.
	* Quest(ion) Feed
	* Context Feed?
	* YES CONTEXT FEED
	* People should not have threaded conversations, they should have Quest(ion) Log queries
	* What is this "Context Feed"
	* A series of call to actions
	* Oooo that needs to be written down
	* Do these separate areas need their own page
	* YES
	* What about the currency side of things?
	* Oh ya, where do we do that?
	* Connections?
	* Or subsection of "Context Feed"
	* Is currency not a type of "Context"
	* Everything is type of context.
	* And profile should manage who you send tokens to.
	* Cool figured out
	* 2023-01-21T13:46:55-05:00
	* Wouldn't it be cool if there were different servers and they were discovered by other people and connected. Well that's what the daemon would expect for itself wouldn't it.
	* Do we want a no user page. No public users.
	* Ah I see.
	* Do we want people to be able to change the Pseudonym
	* Why yes of course, that makes this compatible with Trans ideology
	* 2023-01-21T13:59:13-05:00
	* Shouldn't Randy and Stacy be able to say they don't want to be discovered?
	* Ummmmmmmmmmmmmm
	* That's getting too many features
	* No people that come in should not be in the shadows
	* I want to be in the shadows
	* We adding a public verse private thing toggle
	* This is getting into RBAC, we do that later
	* Alright everything is public for now
	* Except questions, we have not even touched the token stuff yet
	* Ah crap, ya I forgot
	* We have not touched discovery yet
	* How about an enable discovery section,
	* Questions should all cost tokens by default
	* We need question settings
	* Shit we need
	* 2023-01-21T14:12:02-05:00
	* Alright I am working on [[../dentropydaemon-wiki/Projects/Quest(ion|view_persona - Screen]]%20Engine/Pages/view_persona%20-%20Screen.md)
	* I am figuring out what the profile should display, but nobody knows what I am talking about except for me, it is still all in my head
	* I want people to have conversations, conversations are just a series of questions. Or do we want make a difference between statements and conversations. Are there only questions and statements!?!?
	* Ya sure that is simple enought. You are either asking something form the world or articulating how the world works.
	* 2023-01-21T14:26:30-05:00
	* The user should be able to request tokens form a faucet. They can "add as antecedence" to get more tokens.
	* 2023-01-21T15:08:38-05:00
	* Alright what's next
	* No we made a mistake
	* What mistkae
	* All questions should have a answer and question's should have a spot to reply
	* Answer someone's question or respond to them get an additional token
	* 2023-01-21T16:07:30-05:00
	* What about using tokens to respond to others.
	* Do we want it to be that you spend a person's token you gain one?
	* So you get 3 tokens from the faucet,
	* I never said the faucet can be used once or not
	* So if you use a token from someone on them what do you get?
	* Well nothing
	* Which is simpler do that first
	* I feel like we need to go on a walk soon
	* Do you spend tokens to answer somebody 
	* NO
	* You should get a token from them though
	* So upvotes are tokens personally given from someone to someone else
	* YES
	* 2023-01-21T16:16:22-05:00
	* Alright what's next
	* Should randy answer upvote or give stacy a token imediately
	* NO




---

kanban-plugin: basic

---

## Priorities

- [ ] User Stories
- [ ] Code Fronted
- [ ] Project Description / Design Brief


## TODO

- [ ] Query transactions chronologically from a persona
- [ ] Query all public meme's from a persona
- [ ] Query transactions to a persona
- [ ] Query transactions to and from a persona
- [ ] Fetch a single meme


## Working On



## Completed

- [ ] Implement Schema
- [ ] Check cookie for get cookie
- [ ] Cookie Database Integration
- [ ] General cookie checking function
- [ ] Signature verification functions using EthersJS
- [ ] Hash helper using EthersJS
- [ ] Update database to take JSON text for hash verification purposes, do we want a datahash table?
- [ ] Separate validation functions into their own files


## Lazy List

- [ ] Mint and send to other Persona at the same time
- [ ] More database constraints
- [ ] PSEUDONYM constriants
- [ ] Validate Schema with Diagram in Obsidian
- [ ] signign_key or from_user_public_key how do we communicate this better
- [ ] Pagination of query_memes API
- [ ] Rename USER_T to PERSONAS_T
- [ ] Use TOKENS_T rather than TRANSACTIONS_T to verify token exists for transactions like TRANSFER and MINT
- [ ] Check TODO in BURN transaction
- [ ] Fix the symbolisim of perform_transaction, send_transaction!?!?
- [ ] PREVIOUS_TRANSACTION_HASH in mint or VERIFY
- [ ] Add Zero as a taken Pseudonym
- [ ] Script to add test users


***

## Archive

- [ ] Write API
- [ ] Mocha Chai Tests
- [ ] TEST, INCORRECT_SIGNATURE_OF_DATA_HASH
- [ ] Check cookie validation
- [ ] Fix mingint transaciton code and tests
- [ ] Update Schema in Obsidian
- [ ] Schema Design
- [ ] API Design
- [ ] Invalid Cookie Test and document Cookie user flow

%% kanban:settings
```
{"kanban-plugin":"basic"}
```
%%

#### Backlinks

* [Question Engine - QE](/cc5cc49d-f554-4f29-b31a-b8789688e6a3)
* [Backlog - DDaemon](/b9cd3e8b-1727-4a22-9332-90b42b5a7ffb)
* [Backlog - DDaemon](/b9cd3e8b-1727-4a22-9332-90b42b5a7ffb)